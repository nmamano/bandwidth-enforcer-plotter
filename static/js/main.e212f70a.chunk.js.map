{"version":3,"sources":["globals.js","fairShareLogic.js","BandwidthPlot.js","FlowConfigTable.js","FlowGroupList.js","LinkAllocationPlot.js","AllocationLevelTable.js","flowGroup.js","paperExamples.js","App.js","index.js"],"names":["fairShareColor","bandwidthFunctionDataPoints","flowGroup","allocLevels","res","curFs","curBw","fgConfig","i","length","push","prevThreshold","j","threshold","weight","bwIncrement","Math","min","estimatedDemand","maxFairShare","Infinity","allocatedBandwidth","bwFunc","fairShare","x","x0","y0","x1","linearInterpolationY","totalAllocatedBandwidth","bwFunctions","fairShareValues","bwFuncs","Set","add","Array","from","sort","fairShareDataPoints","flowGroups","map","fg","fsValues","fs","allocBw","allocatedBandwidthDataPoints","availableBwFsPairs","availableBwValues","availableBw","allocBwValues","availBw","BandwidthPlot","data","bw","ScatterChart","width","height","name","margin","top","right","left","bottom","CartesianGrid","allocLvl","idx","ReferenceLine","stroke","label","value","position","fill","strokeDasharray","strokeWidth","XAxis","type","dataKey","domain","tickCount","YAxis","style","textAnchor","angle","Tooltip","Scatter","color","line","y","isFront","Styles","styled","div","Table","columns","useTable","getTableProps","getTableBodyProps","headerGroups","rows","prepareRow","headerGroup","getHeaderGroupProps","headers","column","getHeaderProps","render","row","getRowProps","cells","cell","getCellProps","FlowConfigTable","React","useMemo","Header","accessor","allocLevel","bandwidth","subRows","undefined","makeData","FlowGroupList","display","gridTemplateRows","gridTemplateColumns","columnGap","justifyItems","alignItems","justifyContent","LinkAllocationPlot","fairShareData","allocatedBwData","allocBwPoints","albw","availableBwTicks","fsTicks","allocatedBwTicks","ticks","minTickGap","orientation","interval","yAxisId","shape","AllocationLevelTable","prevFs","colors","makeEmptyFlowGroup","numAllocLvls","colorIdx","allocLvls","changeFGName","newName","changeFGEstimatedDemand","newDemand","changeFGThreshold","newBandwidth","changeFGWeight","newWeight","flowGroup1FromPaper","fg1","flowGroup2FromPaper","fg2","App","useImmer","marginLeft","marginTop","rowGap","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e212f70a.chunk.js","sourcesContent":["//max bandwidth estimated demand for a single flowgroup\r\nexport const bandwidthCutoff = 25;\r\n\r\n//max fair share to display in plots\r\nexport const fairShareCutoff = 5;\r\n\r\nexport const availableBandwidthCutoff = 40;\r\n\r\nexport const fairShareColor = \"red\";\r\n","//returns the data points as [fair share, bandwidth] pairs\r\nexport const bandwidthFunctionDataPoints = (flowGroup, allocLevels) => {\r\n  const res = [];\r\n  let [curFs, curBw] = [0, 0];\r\n  const fgConfig = flowGroup.allocLevels;\r\n  for (let i = 0; i < allocLevels.length; i++) {\r\n    res.push([curFs, curBw]);\r\n    let prevThreshold = 0;\r\n    for (let j = 0; j < fgConfig[i].length; j++) {\r\n      let [threshold, weight] = fgConfig[i][j];\r\n      let bwIncrement = Math.min(\r\n        threshold - prevThreshold,\r\n        flowGroup.estimatedDemand - curBw\r\n      );\r\n      prevThreshold = threshold;\r\n      if (weight > 0) {\r\n        curBw += bwIncrement;\r\n        curFs += bwIncrement / weight;\r\n        res.push([curFs, curBw]);\r\n      }\r\n    }\r\n    curFs = allocLevels[i].maxFairShare;\r\n  }\r\n  res.push([Infinity, flowGroup.estimatedDemand]);\r\n  return res;\r\n};\r\n\r\nconst linearInterpolationY = (x, [x0, y0], [x1, y1]) => {\r\n  return y0 + ((x - x0) * (y1 - y0)) / (x1 - x0);\r\n};\r\n\r\n//could be optimized with binary search\r\nconst allocatedBandwidth = (bwFunc, fairShare) => {\r\n  let i = 0;\r\n\r\n  //does not go out of bounds because the last fair share is infinite\r\n  while (bwFunc[i][0] < fairShare) i++;\r\n\r\n  if (bwFunc[i][0] === fairShare) return bwFunc[i][1];\r\n  if (bwFunc[i][0] === Infinity) return bwFunc[i][1]; //bw function is always flat in last segment\r\n  return linearInterpolationY(fairShare, bwFunc[i - 1], bwFunc[i]);\r\n};\r\nconst totalAllocatedBandwidth = (bwFunctions, fairShare) => {\r\n  let res = 0;\r\n  for (let i = 0; i < bwFunctions.length; i++) {\r\n    res += allocatedBandwidth(bwFunctions[i], fairShare);\r\n  }\r\n  return res;\r\n};\r\n\r\nconst fairShareValues = (bwFuncs) => {\r\n  let res = new Set();\r\n  for (let i = 0; i < bwFuncs.length; i++) {\r\n    for (let j = 0; j < bwFuncs[i].length; j++) {\r\n      res.add(bwFuncs[i][j][0]);\r\n    }\r\n  }\r\n  res = Array.from(res);\r\n  res.sort();\r\n  return res;\r\n};\r\n\r\n//returns the data points as [available bw, fair share] pairs\r\nexport const fairShareDataPoints = (flowGroups, allocLevels) => {\r\n  const bwFuncs = flowGroups.map((fg) =>\r\n    bandwidthFunctionDataPoints(fg, allocLevels)\r\n  );\r\n  let fsValues = fairShareValues(bwFuncs);\r\n  const res = [];\r\n  for (let i = 0; i < fsValues.length; i++) {\r\n    const fs = fsValues[i];\r\n    const allocBw = totalAllocatedBandwidth(bwFuncs, fs);\r\n    res.push([allocBw, fs]);\r\n  }\r\n  return res;\r\n};\r\n\r\n//returns the data points as [available bw, allocated bw] pairs\r\nexport const allocatedBandwidthDataPoints = (flowGroups, allocLevels) => {\r\n  const bwFuncs = flowGroups.map((fg) =>\r\n    bandwidthFunctionDataPoints(fg, allocLevels)\r\n  );\r\n  const availableBwFsPairs = fairShareDataPoints(flowGroups, allocLevels);\r\n  let fsValues = fairShareValues(bwFuncs);\r\n  let availableBwValues = [];\r\n  for (let i = 0; i < availableBwFsPairs.length; i++) {\r\n    const [availableBw, fs] = availableBwFsPairs[i];\r\n    if (i === 0 || fs !== availableBwFsPairs[i - 1][1]) {\r\n      availableBwValues.push(availableBw);\r\n    }\r\n  }\r\n  const res = [];\r\n  for (let i = 0; i < bwFuncs.length; i++) {\r\n    const allocBwValues = [];\r\n    for (let j = 0; j < fsValues.length; j++) {\r\n      const availBw = availableBwValues[j];\r\n      if (j === 0 || availBw !== availableBwValues[j - 1]) {\r\n        allocBwValues.push([\r\n          availableBwValues[j],\r\n          allocatedBandwidth(bwFuncs[i], fsValues[j]),\r\n        ]);\r\n      }\r\n    }\r\n    allocBwValues.push([Infinity, allocBwValues[allocBwValues.length - 1][1]]);\r\n    res.push(allocBwValues);\r\n  }\r\n  return res;\r\n};\r\n","import React from \"react\";\r\nimport {\r\n  ScatterChart,\r\n  Scatter,\r\n  CartesianGrid,\r\n  XAxis,\r\n  YAxis,\r\n  Tooltip,\r\n  ReferenceLine,\r\n} from \"recharts\";\r\nimport { bandwidthCutoff, fairShareCutoff, fairShareColor } from \"./globals\";\r\nimport { bandwidthFunctionDataPoints } from \"./fairShareLogic\";\r\n\r\nfunction BandwidthPlot({ flowGroup, allocLevels }) {\r\n  let data = bandwidthFunctionDataPoints(flowGroup, allocLevels);\r\n  data = data.map(([fs, bw]) => {\r\n    return { fs: fs === Infinity ? fairShareCutoff : fs, bw: bw };\r\n  });\r\n  //documentation: http://recharts.org/en-US/examples/JointLineScatterChart\r\n  return (\r\n    <ScatterChart\r\n      width={420}\r\n      height={230}\r\n      name={`${flowGroup.name} bandwidth function`}\r\n      margin={{ top: 5, right: 5, left: 5, bottom: 5 }}\r\n    >\r\n      <CartesianGrid />\r\n      {allocLevels.map((allocLvl, idx) => {\r\n        return (\r\n          <ReferenceLine\r\n            key={idx}\r\n            x={allocLvl.maxFairShare}\r\n            stroke={fairShareColor}\r\n            label={{\r\n              value: allocLvl.name + \" alloc.\",\r\n              position: \"insideTopRight\",\r\n              fill: fairShareColor,\r\n            }}\r\n            strokeDasharray=\"3 3\"\r\n            strokeWidth={0.8}\r\n          />\r\n        );\r\n      })}\r\n\r\n      <XAxis\r\n        type=\"number\"\r\n        dataKey=\"fs\"\r\n        domain={[0, fairShareCutoff]}\r\n        name=\"Fair Share\"\r\n        label={{ value: \"Fair Share\", position: \"insideBottom\" }}\r\n        height={40}\r\n        tickCount={11}\r\n      />\r\n      <YAxis\r\n        type=\"number\"\r\n        dataKey=\"bw\"\r\n        name=\"Bandwidth\"\r\n        label={{\r\n          value: \"Allocated Bandwidth\",\r\n          position: \"insideLeft\",\r\n          style: { textAnchor: \"middle\" },\r\n          angle: -90,\r\n        }}\r\n        width={40}\r\n        domain={[0, bandwidthCutoff]}\r\n        tickCount={6}\r\n      />\r\n      <Tooltip />\r\n      {/* <Legend /> */}\r\n      <Scatter\r\n        name=\"Fair Share\"\r\n        data={data}\r\n        fill={flowGroup.color}\r\n        line={{ strokeWidth: 2.5 }}\r\n      />\r\n      <ReferenceLine\r\n        y={flowGroup.estimatedDemand}\r\n        label={{\r\n          value: \"Est. demand\",\r\n          fill: flowGroup.color,\r\n          position: \"insideBottomRight\",\r\n        }}\r\n        stroke={flowGroup.color}\r\n        strokeDasharray=\"3 3\"\r\n        strokeWidth={0.8}\r\n        isFront={true}\r\n      />\r\n    </ScatterChart>\r\n  );\r\n}\r\n\r\nexport default BandwidthPlot;\r\n","import React from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { useTable } from \"react-table\";\r\n\r\n//doc: https://react-table.tanstack.com/docs/examples/grouping\r\n\r\nconst Styles = styled.div`\r\n  padding: 0;\r\n\r\n  table {\r\n    border-spacing: 0;\r\n    border: 1px solid black;\r\n\r\n    tr {\r\n      :last-child {\r\n        td {\r\n          border-bottom: 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    th,\r\n    td {\r\n      margin: 0;\r\n      padding: 0.2rem;\r\n      border-bottom: 1px solid black;\r\n      border-right: 1px solid black;\r\n      text-align: center;\r\n      :last-child {\r\n        border-right: 0;\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nfunction Table({ columns, data }) {\r\n  // Use the state and functions returned from useTable to build your UI\r\n  const {\r\n    getTableProps,\r\n    getTableBodyProps,\r\n    headerGroups,\r\n    rows,\r\n    prepareRow,\r\n  } = useTable({\r\n    columns,\r\n    data,\r\n  });\r\n\r\n  // Render the UI for your table\r\n  return (\r\n    <table {...getTableProps()}>\r\n      <thead>\r\n        {headerGroups.map((headerGroup) => (\r\n          <tr {...headerGroup.getHeaderGroupProps()}>\r\n            {headerGroup.headers.map((column) => (\r\n              <th {...column.getHeaderProps()}>{column.render(\"Header\")}</th>\r\n            ))}\r\n          </tr>\r\n        ))}\r\n      </thead>\r\n      <tbody {...getTableBodyProps()}>\r\n        {rows.map((row, i) => {\r\n          prepareRow(row);\r\n          return (\r\n            <tr {...row.getRowProps()}>\r\n              {row.cells.map((cell) => {\r\n                return <td {...cell.getCellProps()}>{cell.render(\"Cell\")}</td>;\r\n              })}\r\n            </tr>\r\n          );\r\n        })}\r\n      </tbody>\r\n    </table>\r\n  );\r\n}\r\n\r\nconst makeData = (flowGroup, allocLevels) => {\r\n  const res = [];\r\n  for (let i = 0; i < allocLevels.length; i++) {\r\n    for (let j = 0; j < flowGroup.allocLevels[i].length; j++) {\r\n      const bw = flowGroup.allocLevels[i][j][0];\r\n      res.push({\r\n        allocLevel: j === 0 ? allocLevels[i].name : \"\",\r\n        bandwidth: bw === Infinity ? \"\\u221E\" : bw,\r\n        weight: flowGroup.allocLevels[i][j][1],\r\n        subRows: undefined,\r\n      });\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\nfunction FlowConfigTable({ flowGroup, allocLevels }) {\r\n  const columns = React.useMemo(\r\n    () => [\r\n      {\r\n        Header: `${flowGroup.name} (${flowGroup.estimatedDemand} est. demand)`,\r\n        columns: [\r\n          {\r\n            Header: \"Allocation Level\",\r\n            accessor: \"allocLevel\",\r\n          },\r\n          {\r\n            Header: \"Weight\",\r\n            accessor: \"weight\",\r\n          },\r\n          {\r\n            Header: \"Bandwidth\",\r\n            accessor: \"bandwidth\",\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n    [flowGroup]\r\n  );\r\n\r\n  const data = React.useMemo(() => makeData(flowGroup, allocLevels), [\r\n    flowGroup,\r\n    allocLevels,\r\n  ]);\r\n\r\n  return (\r\n    <Styles>\r\n      <Table columns={columns} data={data} />\r\n    </Styles>\r\n  );\r\n}\r\n\r\nexport default FlowConfigTable;\r\n","import React from \"react\";\r\nimport BandwidthPlot from \"./BandwidthPlot\";\r\nimport FlowConfigTable from \"./FlowConfigTable\";\r\n\r\nfunction FlowGroupList({ flowGroups, allocLevels }) {\r\n  return (\r\n    <div>\r\n      {flowGroups.map((fg, idx) => {\r\n        return (\r\n          <div\r\n            key={idx}\r\n            style={{\r\n              display: \"grid\",\r\n              gridTemplateRows: \"1fr\",\r\n              gridTemplateColumns: \"auto auto\",\r\n              columnGap: \"5px\",\r\n              justifyItems: \"start\", //horizontal\r\n              alignItems: \"center\", //vertical\r\n              justifyContent: \"start\",\r\n            }}\r\n          >\r\n            <FlowConfigTable flowGroup={fg} allocLevels={allocLevels} />\r\n            <BandwidthPlot flowGroup={fg} allocLevels={allocLevels} />\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FlowGroupList;\r\n","import React from \"react\";\r\nimport {\r\n  ScatterChart,\r\n  Scatter,\r\n  CartesianGrid,\r\n  XAxis,\r\n  YAxis,\r\n  Tooltip,\r\n  ReferenceLine,\r\n} from \"recharts\";\r\nimport {\r\n  availableBandwidthCutoff,\r\n  bandwidthCutoff,\r\n  fairShareCutoff,\r\n  fairShareColor,\r\n} from \"./globals\";\r\nimport {\r\n  fairShareDataPoints,\r\n  allocatedBandwidthDataPoints,\r\n} from \"./fairShareLogic\";\r\n\r\nfunction LinkAllocationPlot({ flowGroups, allocLevels }) {\r\n  const fairShareData = fairShareDataPoints(flowGroups, allocLevels).map(\r\n    ([bw, fs]) => {\r\n      return { bw: bw, fs: fs === Infinity ? fairShareCutoff : fs };\r\n    }\r\n  );\r\n\r\n  const allocatedBwData = allocatedBandwidthDataPoints(\r\n    flowGroups,\r\n    allocLevels\r\n  ).map((allocBwPoints) => {\r\n    return allocBwPoints.map(([availableBw, allocatedBw]) => {\r\n      return {\r\n        bw: availableBw === Infinity ? availableBandwidthCutoff : availableBw,\r\n        albw: allocatedBw,\r\n      };\r\n    });\r\n  });\r\n\r\n  const availableBwTicks = [];\r\n  const availableBwTickStep = 2.5;\r\n  for (let i = 0; i <= availableBandwidthCutoff; i += availableBwTickStep) {\r\n    availableBwTicks.push(i);\r\n  }\r\n  const fsTicks = [];\r\n  const fsTickStep = 0.5;\r\n  for (let i = 0; i <= fairShareCutoff; i += fsTickStep) {\r\n    fsTicks.push(i);\r\n  }\r\n  const allocatedBwTicks = [];\r\n  const allocatedBwTickStep = 2.5;\r\n  for (let i = 0; i <= bandwidthCutoff; i += allocatedBwTickStep) {\r\n    allocatedBwTicks.push(i);\r\n  }\r\n\r\n  return (\r\n    <ScatterChart\r\n      width={644}\r\n      height={390}\r\n      name={`Available vs allocated bandwidth`}\r\n      margin={{ top: 5, right: 5, left: 5, bottom: 5 }}\r\n    >\r\n      <CartesianGrid />\r\n      <XAxis\r\n        type=\"number\"\r\n        dataKey=\"bw\"\r\n        domain={[0, availableBandwidthCutoff]}\r\n        label={{ value: \"Available Bandwidth\", position: \"insideBottom\" }}\r\n        height={40}\r\n        name=\"Available Bandwidth\"\r\n        ticks={availableBwTicks}\r\n        minTickGap={2}\r\n      />\r\n      <YAxis\r\n        type=\"number\"\r\n        dataKey=\"albw\"\r\n        domain={[0, fairShareCutoff]}\r\n        name=\"Allocated Bandwidth\"\r\n        label={{\r\n          value: \"Allocated Bandwidth\",\r\n          position: \"insideLeft\",\r\n          style: { textAnchor: \"middle\" },\r\n          angle: -90,\r\n        }}\r\n        width={50}\r\n        ticks={allocatedBwTicks}\r\n        orientation={\"left\"}\r\n        minTickGap={0}\r\n        interval={0}\r\n        yAxisId=\"left\"\r\n      />\r\n      <YAxis\r\n        type=\"number\"\r\n        dataKey=\"fs\"\r\n        domain={[0, fairShareCutoff]}\r\n        name=\"Fair Share\"\r\n        label={{\r\n          value: \"Fair Share\",\r\n          position: \"insideRight\",\r\n          style: { textAnchor: \"middle\" },\r\n          angle: -90,\r\n        }}\r\n        width={50}\r\n        ticks={fsTicks}\r\n        orientation={\"right\"}\r\n        minTickGap={0}\r\n        interval={0}\r\n        yAxisId=\"right\"\r\n      />\r\n      <Tooltip />\r\n      {/* <Legend /> */}\r\n      <Scatter\r\n        name=\"Fair Share\"\r\n        data={fairShareData}\r\n        fill={fairShareColor}\r\n        line={{ strokeWidth: 2 }}\r\n        shape=\"cross\"\r\n        yAxisId=\"right\"\r\n      />\r\n      {allocatedBwData.map((allocBwPoints, idx) => {\r\n        return (\r\n          <Scatter\r\n            key={`ab${idx}`}\r\n            name=\"Allocated Bandwidth\"\r\n            data={allocBwPoints}\r\n            fill={flowGroups[idx].color}\r\n            line={{ strokeWidth: 2.5 }}\r\n            yAxisId=\"left\"\r\n          />\r\n        );\r\n      })}\r\n      {flowGroups.map((fg, idx) => {\r\n        return (\r\n          <ReferenceLine\r\n            key={`ed${idx}`}\r\n            y={fg.estimatedDemand}\r\n            yAxisId=\"left\"\r\n            label={{\r\n              value: \"Est. demand\",\r\n              fill: fg.color,\r\n              position: \"insideBottomLeft\",\r\n            }}\r\n            stroke={fg.color}\r\n            strokeDasharray=\"3 3\"\r\n            strokeWidth={0.8}\r\n            isFront={true}\r\n          />\r\n        );\r\n      })}\r\n      {allocLevels.map((allocLvl, idx) => {\r\n        return (\r\n          <ReferenceLine\r\n            key={`alloc${idx}`}\r\n            y={allocLvl.maxFairShare}\r\n            yAxisId=\"right\"\r\n            stroke={fairShareColor}\r\n            label={{\r\n              value: allocLvl.name + \" alloc.\",\r\n              position: \"insideTopRight\",\r\n              fill: fairShareColor,\r\n            }}\r\n            strokeDasharray=\"3 3\"\r\n            strokeWidth={0.8}\r\n          />\r\n        );\r\n      })}\r\n    </ScatterChart>\r\n  );\r\n}\r\n\r\nexport default LinkAllocationPlot;\r\n","import React from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { useTable } from \"react-table\";\r\n\r\n//doc: https://react-table.tanstack.com/docs/examples/grouping\r\n\r\nconst Styles = styled.div`\r\n  padding: 0;\r\n\r\n  table {\r\n    border-spacing: 0;\r\n    border: 1px solid black;\r\n\r\n    tr {\r\n      :last-child {\r\n        td {\r\n          border-bottom: 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    th,\r\n    td {\r\n      margin: 0;\r\n      padding: 0.2rem;\r\n      border-bottom: 1px solid black;\r\n      border-right: 1px solid black;\r\n      text-align: center;\r\n\r\n      :last-child {\r\n        border-right: 0;\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nfunction Table({ columns, data }) {\r\n  // Use the state and functions returned from useTable to build your UI\r\n  const {\r\n    getTableProps,\r\n    getTableBodyProps,\r\n    headerGroups,\r\n    rows,\r\n    prepareRow,\r\n  } = useTable({\r\n    columns,\r\n    data,\r\n  });\r\n\r\n  return (\r\n    <table {...getTableProps()}>\r\n      <thead>\r\n        {headerGroups.map((headerGroup) => (\r\n          <tr {...headerGroup.getHeaderGroupProps()}>\r\n            {headerGroup.headers.map((column) => (\r\n              <th {...column.getHeaderProps()}>{column.render(\"Header\")}</th>\r\n            ))}\r\n          </tr>\r\n        ))}\r\n      </thead>\r\n      <tbody {...getTableBodyProps()}>\r\n        {rows.map((row, i) => {\r\n          prepareRow(row);\r\n          return (\r\n            <tr {...row.getRowProps()}>\r\n              {row.cells.map((cell) => {\r\n                return <td {...cell.getCellProps()}>{cell.render(\"Cell\")}</td>;\r\n              })}\r\n            </tr>\r\n          );\r\n        })}\r\n      </tbody>\r\n    </table>\r\n  );\r\n}\r\n\r\nconst makeData = (allocLevels) => {\r\n  const res = [];\r\n  for (let i = 0; i < allocLevels.length; i++) {\r\n    const prevFs = i === 0 ? 0 : allocLevels[i - 1].maxFairShare;\r\n    const fs = allocLevels[i].maxFairShare;\r\n    res.push({\r\n      allocLevel: allocLevels[i].name,\r\n      fairShare: `${prevFs}-${fs === Infinity ? \"\\u221E\" : fs}`,\r\n      subRows: undefined,\r\n    });\r\n  }\r\n  return res;\r\n};\r\n\r\nfunction AllocationLevelTable({ allocLevels }) {\r\n  const columns = React.useMemo(\r\n    () => [\r\n      {\r\n        Header: `Allocation levels`,\r\n        columns: [\r\n          {\r\n            Header: \"\",\r\n            accessor: \"allocLevel\",\r\n          },\r\n          {\r\n            Header: \"Fair Share\",\r\n            accessor: \"fairShare\",\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n    []\r\n  );\r\n\r\n  const data = React.useMemo(() => makeData(allocLevels), [allocLevels]);\r\n\r\n  return (\r\n    <Styles>\r\n      <Table columns={columns} data={data} />\r\n    </Styles>\r\n  );\r\n}\r\n\r\nexport default AllocationLevelTable;\r\n","/*functions to create/manage objects representing flow groups\r\n\r\nA flow group has a name, an estimated demand, an (arbitrary) color,\r\nand, most importantly, the bandwidth requirements:\r\nThere is a list of bandwidth thresholds for each allocation level:\r\nEach threshold, a pair of values [bandwidth, weight]:\r\n- If the flow group requires no bandwidth in this allocation level,\r\nthere should be a single threshold pair [0,0].\r\n- Otherwise, it should contain 1+ pairs where\r\n--- bandwidth values (meaning cumulative bandwidth for that allocation level) \r\nmust be strictly increasing and non-negative.\r\n--- weight values must be strictly decreasing and non-negative\r\nIn addition, the last requirement for the last (least prioritary) allocation level\r\nshould be infinite, since the estimated demand of the flow group already imposes\r\na limit to how much bandwidth is allocated to a flow group.\r\n\r\nfor now, weight is equivalent to the slope in the Bandwidth function,\r\nso the bandwidth requested for each allocation level should be\r\ncompletely allocatable by the point fair share reaches the transition to the next\r\nallocation level. For example, 2.5 bandwidth with weight 1 would be too much for\r\nan allocation level with a range of 0-2 fair share\r\n*/\r\n\r\n/* Makes a flow group that has no name, no estimated demand,\r\nno bandwidth thresholds, and an arbitrary color */\r\nconst colors = [\"#6864b8\", \"#62aa7d\"];\r\nexport const makeEmptyFlowGroup = (numAllocLvls) => {\r\n  //cycle through available colors\r\n  if (makeEmptyFlowGroup.colorIdx === undefined) {\r\n    makeEmptyFlowGroup.colorIdx = 0; //\"static\" variable\r\n  } else {\r\n    makeEmptyFlowGroup.colorIdx =\r\n      (makeEmptyFlowGroup.colorIdx + 1) % colors.length;\r\n  }\r\n  const allocLvls = [];\r\n  for (let i = 0; i < numAllocLvls - 1; i++) allocLvls[i] = [[0, 0]];\r\n  allocLvls.push([[Infinity, 0]]);\r\n  //bandwidth for the last (least prioritary) allocation level is\r\n  //infinite, since the allocated bandwidth is bounded by\r\n  //the estimated demand\r\n  return {\r\n    name: \"\",\r\n    color: colors[makeEmptyFlowGroup.colorIdx],\r\n    estimatedDemand: 0,\r\n    allocLevels: allocLvls,\r\n  };\r\n};\r\n\r\n//functions to modify a flow group\r\n\r\nexport const changeFGName = (fg, newName) => {\r\n  fg.name = newName;\r\n};\r\nexport const changeFGEstimatedDemand = (fg, newDemand) => {\r\n  fg.estimatedDemand = newDemand;\r\n};\r\nexport const addFGThreshold = (fg, allocLvl, newBandwidth, newWeight) => {\r\n  fg.allocLevels[allocLvl].push([newBandwidth, newWeight]);\r\n};\r\nexport const changeFGThreshold = (fg, allocLvl, threshold, newBandwidth) => {\r\n  fg.allocLevels[allocLvl][threshold][0] = newBandwidth;\r\n};\r\nexport const changeFGWeight = (fg, allocLvl, threshold, newWeight) => {\r\n  fg.allocLevels[allocLvl][threshold][1] = newWeight;\r\n};\r\n","//example used in the paper (Table 1, Figures 3-4)\r\n//we use it as default functions for the app\r\n//as well as in unit tests\r\n\r\nimport {\r\n  makeEmptyFlowGroup,\r\n  changeFGName,\r\n  changeFGEstimatedDemand,\r\n  changeFGThreshold,\r\n  changeFGWeight,\r\n  addFGThreshold,\r\n} from \"./flowGroup\";\r\n\r\n//allocation levels should be sorted from most prioritary to least\r\n//guaranteed has the range of fair share [0, 2], and best effort has the range [2, +inf]\r\nexport const allocationLevelsFromPaper = () => [\r\n  { name: \"Guaranteed\", maxFairShare: 2 },\r\n  { name: \"Best Effort\", maxFairShare: Infinity },\r\n];\r\n\r\n//specific flow groups from the paper\r\n//they can be used as defaults for the app\r\n//Table 1 (a)\r\nexport const flowGroup1FromPaper = () => {\r\n  const fg1 = makeEmptyFlowGroup(2);\r\n  changeFGName(fg1, \"fg1\");\r\n  changeFGEstimatedDemand(fg1, 15);\r\n  changeFGThreshold(fg1, 1, 0, 10);\r\n  changeFGWeight(fg1, 1, 0, 20);\r\n  addFGThreshold(fg1, 1, Infinity, 5);\r\n  return fg1;\r\n};\r\n\r\n//Table 1 (b)\r\nexport const flowGroup2FromPaper = () => {\r\n  const fg2 = makeEmptyFlowGroup(2);\r\n  changeFGName(fg2, \"fg2\");\r\n  changeFGEstimatedDemand(fg2, 20);\r\n  changeFGThreshold(fg2, 0, 0, 10);\r\n  changeFGWeight(fg2, 0, 0, 10);\r\n  changeFGWeight(fg2, 1, 0, 10);\r\n  return fg2;\r\n};\r\n","import { useImmer } from \"use-immer\";\nimport \"./App.css\";\nimport FlowGroupList from \"./FlowGroupList\";\nimport LinkAllocationPlot from \"./LinkAllocationPlot\";\nimport AllocationLevelTable from \"./AllocationLevelTable\";\nimport {\n  allocationLevelsFromPaper,\n  flowGroup1FromPaper,\n  flowGroup2FromPaper,\n} from \"./paperExamples\";\n// eslint-disable-next-line\nimport { allTests } from \"./tests\";\n\nfunction App() {\n  // eslint-disable-next-line\n  const [allocLevels, updateAllocLevels] = useImmer(\n    allocationLevelsFromPaper()\n  );\n  // eslint-disable-next-line\n  const [flowGroups, updateFlowGroups] = useImmer([\n    flowGroup1FromPaper(),\n    flowGroup2FromPaper(),\n  ]);\n\n  // allTests();\n\n  return (\n    <div\n      style={{\n        display: \"grid\",\n        gridTemplateRows: \"1fr\",\n        gridTemplateColumns: \"auto auto\",\n        columnGap: \"20px\",\n        justifyItems: \"start\", //horizontal\n        alignItems: \"center\", //vertical\n        justifyContent: \"start\",\n        marginLeft: \"15px\",\n        marginTop: \"15px\",\n      }}\n    >\n      <div\n        style={{\n          display: \"grid\",\n          gridTemplateRows: \"auto auto\",\n          gridTemplateColumns: \"auto\",\n          rowGap: \"15px\",\n          justifyItems: \"center\", //horizontal\n          alignItems: \"center\", //vertical\n          justifyContent: \"center\",\n        }}\n      >\n        <AllocationLevelTable allocLevels={allocLevels} />\n        <FlowGroupList flowGroups={flowGroups} allocLevels={allocLevels} />\n      </div>\n      <LinkAllocationPlot flowGroups={flowGroups} allocLevels={allocLevels} />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}