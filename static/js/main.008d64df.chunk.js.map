{"version":3,"sources":["globals.js","utils.js","fairShareLogic.js","BandwidthPlot.js","IncrementableButton.js","FlowConfigTable.js","FlowGroupList.js","LinkAllocationPlot.js","AllocationLevelTable.js","paperExamples.js","App.js","index.js"],"names":["fairShareColor","removeFlatPoints","points","P","push","i","length","res","slope1","Infinity","slope2","Math","abs","makeEmptyFlowGroup","name","color","estBandwidth","numAllocLvls","allocLvls","estimatedDemand","allocLevels","bandwidthFunctionDataPoints","flowGroup","accumFs","accumBw","fgConfig","prevBw","j","bw","weight","bwIncrement","min","maxFairShare","allocatedBandwidth","bwFunc","fairShare","x","x0","y0","x1","linearInterpolationY","totalAllocatedBandwidth","bwFunctions","linkFairShareDataPoints","bwFuncs","fsValues","Set","add","Array","from","sort","a","b","console","assert","fairShareValues","map","fs","allocatedBandwidthDataPoints","linkCapFsPairs","linkCap","allocatedBwSingleFg","thresholdChangeViolatesFairShareSpan","allocationLevels","allocLvlIdx","thresholdIdx","isWeight","isInc","modifiedThresholdList","p","modifiedIdx","thresholds","neededFairshare","allocLvl","fairShareSpan","BandwidthPlot","pts","plotMaxFs","reduce","accum","max","data","idx","ScatterChart","width","height","margin","top","right","left","bottom","CartesianGrid","ReferenceLine","stroke","label","value","position","fill","strokeDasharray","strokeWidth","XAxis","type","dataKey","domain","tickCount","YAxis","style","textAnchor","angle","Tooltip","Scatter","line","y","isFront","IncrementableButton","text","onDec","onInc","thickBottom","thickRight","disabled","disabledInc","disabledDec","borderStyle","thickBorderStyle","borderBottom","borderRight","textAlign","display","gridTemplateRows","gridTemplateColumns","justifyItems","alignItems","MozUserSelect","WebkitUserSelect","msUserSelect","userSelect","useState","hoveredMin","setHoveredMin","hoveredMax","setHoveredMax","buttonBgCol","hoveredBgCol","disabledButtonBgCol","disabledButtonTextCol","incDisabled","decDisabled","backgroundColor","cursor","onMouseEnter","onMouseLeave","onClick","padding","borderLeft","FlowConfigTable","handleEstDemand","handleNumWeightThresholds","handleWeightThreshold","buttonWidth","tableStyle","borderTop","cellStyle","justifySelf","alignSelf","headerStyle","fontWeight","topHeaderStyle","allocLvlDivStyle","allocTextDivStyle","weightThresholdButtonStyle","fontSize","paddingTop","topHeader","topHeaderDiv","estBwDiv","estBwButton","estBwRow","justifyContent","headers","headerDivs","sty","entryDivs","rowCount","addWeightThresholdButton","removeWeightThesholdButton","isFirst","isLast","removeButtonHere","addButtonHere","allocLvlText","divStyle","undefined","allocLvlDiv","maxW","minW","weightButton","maxBw","minBw","bwButton","entryRows","div","FlowGroupList","flowGroups","handleNumFlowGroups","addFgButtonStyle","removeFgButtonStyle","addFgButton","removeFgButton","fg","fgIdx","columnGap","weightThresholdIdx","LinkAllocationPlot","fsPts","fairShareData","cap","prevCap","totalNeededLinkCap","plotMaxCap","allocatedBwPts","allocBwPts","availableBw","allocatedBw","allocBw","availableBwTicks","fsTicks","allocatedBwTicks","ticks","minTickGap","orientation","interval","yAxisId","shape","allocBwPoints","AllocationLevelTable","entries","prevFs","entryStyle","divs","flowGroup1FromPaper","fg1","flowGroup2FromPaper","fg2","fgColors","App","useImmer","updateFlowGroups","flowGroupDivStyle","rowGap","bandwidthAggregationDivStyle","marginLeft","marginTop","isIncrement","draftFgs","isLastLvl","th","n","pop","lastBw","lastW","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"wVAUaA,EAAiB,M,SCPjBC,EAAmB,SAACC,GAC/B,IAAMC,EAAI,GACVA,EAAEC,KAAKF,EAAO,IACd,IAAK,IAAIG,EAAI,EAAGA,EAAIH,EAAOI,OAAQD,GAAK,EAClCH,EAAOG,GAAG,KAAOH,EAAOG,EAAI,GAAG,IAAMH,EAAOG,GAAG,KAAOH,EAAOG,EAAI,GAAG,IAExEF,EAAEC,KAAKF,EAAOG,IAEhB,IAAME,EAAM,GACZA,EAAIH,KAAKD,EAAE,IACX,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAEG,OAAS,EAAGD,GAAK,EACrC,GAAIF,EAAEE,EAAI,GAAG,KAAOF,EAAEE,EAAI,GAAG,GAC7B,GAAIF,EAAEE,EAAI,GAAG,KAAOF,EAAEE,GAAG,IAAMF,EAAEE,GAAG,KAAOF,EAAEE,EAAI,GAAG,GAApD,CAKA,IAAMG,GAAUL,EAAEE,GAAG,GAAKF,EAAEE,EAAI,GAAG,KAAOF,EAAEE,GAAG,GAAKF,EAAEE,EAAI,GAAG,IAC7D,GAAIF,EAAEE,EAAI,GAAG,KAAOI,IACH,IAAXD,GAAcD,EAAIH,KAAKD,EAAEE,SACxB,GAAIF,EAAEE,EAAI,GAAG,KAAOI,IACzBF,EAAIH,KAAKD,EAAEE,QACN,CACL,IAAMK,GAAUP,EAAEE,EAAI,GAAG,GAAKF,EAAEE,GAAG,KAAOF,EAAEE,EAAI,GAAG,GAAKF,EAAEE,GAAG,IAEzDM,KAAKC,IAAIJ,EAASE,GAAU,MAC9BH,EAAIH,KAAKD,EAAEE,UAZbE,EAAIH,KAAKD,EAAEE,IAiBf,OADAE,EAAIH,KAAKD,EAAEA,EAAEG,OAAS,IACfC,GCTIM,EAAqB,SAACC,EAAMC,EAAOC,EAAcC,GAE5D,IADA,IAAMC,EAAY,GACTb,EAAI,EAAGA,EAAIY,EAAe,EAAGZ,IAAKa,EAAUb,GAAK,CAAC,CAAC,EAAG,IAE/D,OADAa,EAAUd,KAAK,CAAC,CAACK,IAAU,KACpB,CACLK,KAAMA,EACNC,MAAOA,EACPI,gBAAiBH,EACjBI,YAAaF,IAQJG,EAA8B,SAACC,EAAWF,GAIrD,IAHA,IAAMb,EAAM,GACPgB,EAAqB,EAAZC,EAAe,EACvBC,EAAWH,EAAUF,YAClBf,EAAI,EAAGA,EAAIe,EAAYd,OAAQD,IAAK,CAC3CE,EAAIH,KAAK,CAACmB,EAASC,IAEnB,IADA,IAAIE,EAAS,EACJC,EAAI,EAAGA,EAAIF,EAASpB,GAAGC,OAAQqB,IAAK,CAAC,IAAD,cACxBF,EAASpB,GAAGsB,GADY,GACtCC,EADsC,KAClCC,EADkC,KAEvCC,EAAcnB,KAAKoB,IACrBH,EAAKF,EACLJ,EAAUH,gBAAkBK,GAE9BE,EAASE,EACLC,EAAS,IACXN,GAAWO,EAAcD,EACzBL,GAAWM,EACXvB,EAAIH,KAAK,CAACmB,EAASC,KAIvBD,EAAUH,EAAYf,GAAG2B,aAG3B,OADAzB,EAAIH,KAAK,CAACK,IAAUe,IACbvB,EAAiBM,IAMpB0B,EAAqB,SAACC,EAAQC,GAClC,GAAIA,IAAc1B,IAAU,OAAOyB,EAAOA,EAAO5B,OAAS,GAAG,GAI7D,IAFA,IAAID,EAAI,EAED6B,EAAO7B,GAAG,GAAK8B,GAAW9B,IAEjC,OAAI6B,EAAO7B,GAAG,KAAO8B,GACjBD,EAAO7B,GAAG,KAAOI,IADkByB,EAAO7B,GAAG,GDzCf,SAAC+B,EAAD,KAA4B,IAAD,mBAAtBC,EAAsB,KAAlBC,EAAkB,wBAAZC,EAAY,KAC7D,OAAOD,GAAOF,EAAIC,IAD2C,KAC/BC,IAAQC,EAAKF,GC0CpCG,CAAqBL,EAAWD,EAAO7B,EAAI,GAAI6B,EAAO7B,KAKzDoC,EAA0B,SAACC,EAAaP,GAE5C,IADA,IAAI5B,EAAM,EACDF,EAAI,EAAGA,EAAIqC,EAAYpC,OAAQD,IACtCE,GAAO0B,EAAmBS,EAAYrC,GAAI8B,GAE5C,OAAO5B,GAyBIoC,EAA0B,SAACD,GACtC,IACMnC,EAtBgB,SAACqC,GAEvB,IADA,IAAMC,EAAW,IAAIC,IACZzC,EAAI,EAAGA,EAAIuC,EAAQtC,OAAQD,IAClC,IAAK,IAAIsB,EAAI,EAAGA,EAAIiB,EAAQvC,GAAGC,OAAQqB,IACrCkB,EAASE,IAAIH,EAAQvC,GAAGsB,GAAG,IAG/B,IAAMpB,EAAMyC,MAAMC,KAAKJ,GAGvB,OAFAtC,EAAI2C,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,KACvBC,QAAQC,OAAO/C,EAAIA,EAAID,OAAS,KAAOG,KAChCF,EAWUgD,CAAgBb,GACZc,KAAI,SAACC,GAAD,MAAQ,CAC/BhB,EAAwBC,EAAae,GACrCA,MAEF,OAAOxD,EAAiBM,IAMbmD,EAA+B,SAACd,GAC3C,IAAMe,EAAiBhB,EAAwBC,GAa/C,OAAOA,EAAQY,KAAI,SAACtB,GAAD,OAXS,SAACA,GAC3B,IAAM3B,EAAMoD,EAAeH,KAAI,mCAAEI,EAAF,KAAWH,EAAX,WAAmB,CAChDG,EACA3B,EAAmBC,EAAQuB,OAK7B,OAFAlD,EAAIH,KAAK,CAACK,IAAUF,EAAIA,EAAID,OAAS,GAAG,KAEjCL,EAAiBM,GAGKsD,CAAoB3B,OAuCxC4B,EAAuC,SAClDxC,EACAyC,EACAC,EACAC,EACAC,EACAC,GAGA,IAAIC,EAAwB9C,EAAUF,YAAY4C,GAAaR,KAAI,SAACa,GAAD,mBAC9DA,MAECC,EAAcJ,EAAW,EAAI,EAEnC,OADAE,EAAsBH,GAAcK,IAAgBH,EAAQ,GAAK,EA3C3C,SAACI,GAEvB,GAAIA,EAAWA,EAAWjE,OAAS,GAAG,KAAOG,IAAU,OAAOA,IAG9D,IAFA,IAAIc,EAAU,EACVG,EAAS,EACJrB,EAAI,EAAGA,EAAIkE,EAAWjE,OAAQD,IAAK,CAAC,IAAD,cACvBkE,EAAWlE,GADY,GACrCuB,EADqC,KACjCC,EADiC,KAEtCC,EAAcF,EAAKF,EACvBA,EAASE,EACLC,EAAS,IACXN,GAAWO,EAAcD,GAG7B,OAAON,EAgCLiD,CAAgBJ,GA3BE,SAACL,EAAkBC,GAEvC,GAAIA,IAAgBD,EAAiBzD,OAAS,EAAG,OAAOG,IACxD,IAAMgE,EAAWV,EAAiBC,GAClC,OAAoB,IAAhBA,EAA0BS,EAASzC,aAChCyC,EAASzC,aAAe+B,EAAiBC,EAAc,GAAGhC,aAuB/D0C,CAAcX,EAAkBC,IClGrBW,MArFf,YAAoD,IAA3BrD,EAA0B,EAA1BA,UAAWF,EAAe,EAAfA,YAC5BwD,EAAMvD,EAA4BC,EAAWF,GAC7CyD,EAAYD,EAAIE,QACpB,SAACC,EAAD,0BAAStB,EAAT,iBAAsBA,IAAOhD,IAAWsE,EAAQpE,KAAKqE,IAAID,EAAOtB,EAAK,KHdrC,GGiB5BwB,EAAOL,EAAIpB,KAAI,WAAW0B,GAAS,IAAD,mBAAjBzB,EAAiB,KAAb7B,EAAa,KAChCF,EAAiB,IAARwD,EAAY,EAAIN,EAAIM,EAAM,GAAG,GAE5C,OADA7B,QAAQC,OAAOG,IAAOhD,KAAYmB,IAAOF,EAAQE,EAAIF,GAC9C+B,IAAOhD,IAAW,CAAEgD,GAAIoB,EAAWjD,GAAIF,GAAW,CAAE+B,GAAIA,EAAI7B,GAAIA,MAIzE,OACE,eAACuD,EAAA,EAAD,CACEC,MAAO,IACPC,OAAQ,IACRvE,KAAI,UAAKQ,EAAUR,KAAf,uBACJwE,OAAQ,CAAEC,IAAK,EAAGC,MAAO,EAAGC,KAAM,EAAGC,OAAQ,GAJ/C,UAME,cAACC,EAAA,EAAD,IACCvE,EAAYoC,KAAI,SAACiB,EAAUS,GAC1B,OACE,cAACU,EAAA,EAAD,CAEExD,EAAGqC,EAASzC,aACZ6D,OAAQ7F,EACR8F,MAAO,CACLC,MAAOtB,EAAS3D,KAAO,UACvBkF,SAAU,iBACVC,KAAMjG,GAERkG,gBAAgB,MAChBC,YAAa,IATRjB,MAcX,cAACkB,EAAA,EAAD,CACEC,KAAK,SACLC,QAAQ,KACRC,OAAQ,CAAC,EHpDmB,GGqD5BzF,KAAK,aACLgF,MAAO,CAAEC,MAAO,aAAcC,SAAU,gBACxCX,OAAQ,GACRmB,UAAW,KAEb,cAACC,EAAA,EAAD,CACEJ,KAAK,SACLC,QAAQ,KACRxF,KAAK,YACLgF,MAAO,CACLC,MAAO,sBACPC,SAAU,aACVU,MAAO,CAAEC,WAAY,UACrBC,OAAQ,IAEVxB,MAAO,GACPmB,OAAQ,CAAC,EHtEW,IGuEpBC,UAAW,IAEb,cAACK,EAAA,EAAD,IAEA,cAACC,EAAA,EAAD,CACEhG,KAAK,aACLmE,KAAMA,EACNgB,KAAM3E,EAAUP,MAChBgG,KAAM,CAAEZ,YAAa,OAEvB,cAACP,EAAA,EAAD,CACEoB,EAAG1F,EAAUH,gBACb2E,MAAO,CACLC,MAAO,cACPE,KAAM3E,EAAUP,MAChBiF,SAAU,qBAEZH,OAAQvE,EAAUP,MAClBmF,gBAAgB,MAChBC,YAAa,GACbc,SAAS,Q,QCMFC,MAhGf,YAaI,IAZFnB,EAYC,EAZDA,MACAoB,EAWC,EAXDA,KACApF,EAUC,EAVDA,IACAiD,EASC,EATDA,IACAoC,EAQC,EARDA,MACAC,EAOC,EAPDA,MACAjC,EAMC,EANDA,MACAkC,EAKC,EALDA,YACAC,EAIC,EAJDA,WACAC,EAGC,EAHDA,SACAC,EAEC,EAFDA,YACAC,EACC,EADDA,YAEMC,EAAc,kBACdC,EAAmB,kBACnBlB,EAAQ,CACZmB,aAAcP,EAAcM,EAAmBD,EAC/CG,YAAaP,EAAaK,EAAmBD,EAC7CI,UAAW,SACXC,QAAS,OACTC,iBAAkB,OAClBC,oBAAoB,QAAD,OAAU9C,EAAQ,GAAlB,WACnB+C,aAAc,UACdC,WAAY,UACZC,cAAe,OACfC,iBAAkB,OAClBC,aAAc,OACdC,WAAY,QAfb,EAiBmCC,oBAAS,GAjB5C,mBAiBMC,EAjBN,KAiBkBC,EAjBlB,OAkBmCF,oBAAS,GAlB5C,mBAkBMG,EAlBN,KAkBkBC,EAlBlB,KAoBKC,EAAc,UACdC,EAAe,UAEfC,EAAsB,UACtBC,EAAwB,UAExBC,EAAc1B,GAAYC,GAAe1B,EAAQ,EAAIf,EACrDmE,EAAc3B,GAAYE,GAAe3B,EAAQ,EAAIhE,EAE3D,OACE,sBAAK2E,MAAOA,EAAZ,UACE,qBACEA,MAAO,CACLoB,YAAaH,EACb5G,MAAOoI,EAAcF,EAAwB,QAC7CG,gBAAiBD,EACbH,EACAN,EACAK,EACAD,EACJO,OAAQF,EAAc,cAAgB,WAExCG,aAAc,kBAAMX,GAAc,IAClCY,aAAc,kBAAMZ,GAAc,IAClCa,QAAS,WACFL,GAAa/B,KAdtB,eAmBA,qBACEV,MAAO,CACL0C,gBA9BW,UA+BXhB,WAAY,UACZqB,QAAS,SAJb,SAOGtC,IAAcpB,IAAUtF,IAAW,SAAWsF,KAEjD,qBACEW,MAAO,CACLgD,WAAY/B,EACZG,YAAaP,EAAaK,EAAmBD,EAC7C5G,MAAOmI,EAAcD,EAAwB,QAC7CG,gBAAiBF,EACbF,EACAJ,EACAG,EACAD,EACJO,OAAQH,EAAc,cAAgB,WAExCI,aAAc,kBAAMT,GAAc,IAClCU,aAAc,kBAAMV,GAAc,IAClCW,QAAS,WACFN,GAAa7B,KAftB,mBCsLSsC,MApPf,YAMI,IALFrI,EAKC,EALDA,UACAF,EAIC,EAJDA,YACAwI,EAGC,EAHDA,gBACAC,EAEC,EAFDA,0BACAC,EACC,EADDA,sBAGMC,EAAc,GAEdpC,EAAc,kBACdC,EAAmB,kBACnBoC,EAAa,CACjBC,UAAWrC,EACX8B,WAAY9B,GAERsC,EAAY,CAChBrC,aAAcF,EACdG,YAAaH,EACbI,UAAW,SACXoC,YAAa,UACbC,UAAW,WAEPC,EAAW,eAAQH,GACzBG,EAAYC,WAAa,OACzBD,EAAYZ,QAAU,SACtBY,EAAYxC,aAAeD,EAC3B,IAAM2C,EAAc,eAAQF,GAC5BE,EAAexJ,MAAQO,EAAUP,MACjCwJ,EAAezC,YAAcF,EAE7B,IAAM4C,EAAgB,eAAQN,GAC9BM,EAAiBxC,QAAU,OAC3BwC,EAAiBvC,iBAAmB,OACpCuC,EAAiBtC,oBAAsB,gBACvCsC,EAAiBpC,WAAa,SA8D9B,IA7DA,IAAMqC,EAAoB,CAAEN,YAAa,SACnCO,EAA6B,CACjCrB,OAAQ,UACRhB,cAAe,OACfC,iBAAkB,OAClBC,aAAc,OACdC,WAAY,OACZmC,SAAU,OACVC,WAAY,UAGRC,EAAS,UAAMvJ,EAAUR,MACzBgK,EAAe,qBAAKpE,MAAO6D,EAAZ,SAA6BM,IAE5CE,EAAW,qBAAKrE,MAAO2D,EAAZ,4BACXW,EACJ,cAAC,EAAD,CACEjF,MAAOzE,EAAUH,gBACjBY,IAAK,EACLiD,IL9DsB,GK+DtBqC,MAAO,WACLuC,GAAgB,IAElBxC,MAAO,WACLwC,GAAgB,IAElBxE,MAAO2E,EACPzC,aAAW,EACXC,YAAU,IAGR0D,EACJ,sBACEvE,MAAO,CACLsB,QAAS,OACTC,iBAAiB,MACjBC,oBAAoB,OAAD,OAAS6B,EAAT,MACnB5B,aAAc,UACdC,WAAY,UACZ8C,eAAgB,UAChB9F,MAAM,GAAD,OArEQ,IAqER,OART,UAWG2F,EACAC,KAICG,EAAU,CAAC,mBAAoB,SAAU,aACzCC,EAAaD,EAAQ3H,KAAI,SAAC2D,EAAMjC,GACpC,IAAMmG,EAAG,eAAQhB,GAEjB,OADInF,IAAQiG,EAAQ7K,OAAS,IAAG+K,EAAIvD,YAAcF,GAEhD,qBAAqBlB,MAAO2E,EAA5B,SACGlE,GADH,WAAcjC,OAMZoG,EAAY,GACdC,EAAW,EA1Fd,WA2FQlL,GACPkL,GAAYjK,EAAUF,YAAYf,GAAGC,OAiBrC,IAhBA,IAAMkL,EACJ,qBACE9E,MAAOgE,EACPlB,QAAS,kBAAMK,EAA0BxJ,GAAG,IAF9C,SAIE,cAAC,IAAD,MAGEoL,EACJ,qBACE/E,MAAOgE,EACPlB,QAAS,kBAAMK,EAA0BxJ,GAAG,IAF9C,SAIE,cAAC,IAAD,MA1GL,WA6GUsB,GACP,IAAM+J,EAAgB,IAAN/J,EACVgK,EAAShK,IAAML,EAAUF,YAAYf,GAAGC,OAAS,EACjDsL,EAAmBD,IAAWD,EAC9BG,EAAgBF,GAAUhK,EL3HA,EKUnC,cAkHwBL,EAAUF,YAAYf,GAAGsB,GAlHjD,GAkHUC,EAlHV,KAkHcC,EAlHd,KAmHSiK,EAAeJ,EAAUtK,EAAYf,GAAGS,KAAO,GAC/CiL,EAAQ,eAAQvB,GAIpBuB,EAASlE,aAHN8D,EAGqB/D,OAFAoE,EAI1B,IAAMC,EACJ,sBAAwBvF,MAAOqF,EAA/B,UACE,qBAAKrF,MAAO+D,EAAZ,SAAgCqB,IAC/BF,EAAmBH,EAA6B,wBAChDI,EAAgBL,EAA2B,0BAH9C,WAAcnL,EAAd,YAAmBsB,IAMfuK,EAAOR,EL7IQ,IK6IgBpK,EAAUF,YAAYf,GAAGsB,EAAI,GAAG,GAC/DwK,EAAOR,EAAS,EAAIrK,EAAUF,YAAYf,GAAGsB,EAAI,GAAG,GACpDyK,EACJ,cAAC,EAAD,CAEErG,MAAOlE,EACPE,IAAKoK,EACLnH,IAAKkH,EACL7E,MAAO,WACLyC,EAAsBzJ,EAAGsB,GAAG,GAAM,IAEpCyF,MAAO,WACL0C,EAAsBzJ,EAAGsB,GAAG,GAAM,IAEpC8F,YAAa3D,EACXxC,EACAF,EACAf,EACAsB,GACA,GACA,GAEF+F,YAAa5D,EACXxC,EACAF,EACAf,EACAsB,GACA,GACA,GAEFyD,MAAO2E,EACPzC,YAAaqE,GA5Bf,WACWtL,EADX,YACgBsB,IA8BZ0K,EAAQV,EL9KU,IKgLpBrK,EAAUF,YAAYf,GAAGsB,EAAI,GAAG,GAC9B2K,EAAQZ,EAAU,EAAIpK,EAAUF,YAAYf,GAAGsB,EAAI,GAAG,GACtD4K,EACJ,cAAC,EAAD,CAEExG,MAAOnE,EACPuF,KACE,iCACE,sBAAMT,MAAO,CAAE3F,MAAO,QAAtB,mBAAoCuL,EAApC,OACA,yCAAU1K,IAAOnB,IAAW,SAAWmB,QAG3CG,IAAKuK,EACLtH,IAAKqH,EACLhF,MAAO,WACLyC,EAAsBzJ,EAAGsB,GAAG,GAAO,IAErCyF,MAAO,WACL0C,EAAsBzJ,EAAGsB,GAAG,GAAO,IAErC6F,SAAU5F,IAAOnB,KAAuB,IAAXoB,EAC7B4F,YAAa3D,EACXxC,EACAF,EACAf,EACAsB,GACA,GACA,GAEF+F,YAAa5D,EACXxC,EACAF,EACAf,EACAsB,GACA,GACA,GAEFyD,MAAO2E,EACPzC,YAAaqE,EACbpE,YAAU,GApCZ,WACWlH,EADX,YACgBsB,IAsClB2J,EAAUlL,KAAK6L,GACfX,EAAUlL,KAAKgM,GACfd,EAAUlL,KAAKmM,IApGR5K,EAAI,EAAGA,EAAIL,EAAUF,YAAYf,GAAGC,OAAQqB,IAAM,EAAlDA,IAlBFtB,EAAI,EAAGA,EAAIe,EAAYd,OAAQD,IAAM,EAArCA,GAyHT,IAAMmM,EACJ,sBACE9F,MAAO,CACLsB,QAAS,OACTC,iBAAiB,UAAD,OAAYsD,EAAZ,UAChBrD,oBAAoB,OAAD,OAAS6B,EAAT,cAA0BA,EAA1B,MACnB5B,aAAc,UACdC,WAAY,UACZ8C,eAAgB,UAChB9F,MAAM,GAAD,OA5NQ,IA4NR,OART,UAWGgG,EAAW5H,KAAI,SAACiJ,GAAD,OAASA,KACxBnB,EAAU9H,KAAI,SAACiJ,GAAD,OAASA,QAI5B,OACE,sBAAK/F,MAAOsD,EAAZ,UACGc,EACAG,EACAuB,MC3JQE,MA1Ff,YAOI,IANFC,EAMC,EANDA,WACAvL,EAKC,EALDA,YACAwI,EAIC,EAJDA,gBACAC,EAGC,EAHDA,0BACAC,EAEC,EAFDA,sBACA8C,EACC,EADDA,oBAEMC,EAAmB,CACvB1C,YAAa,QACbd,OAAQ,UACRhB,cAAe,OACfC,iBAAkB,OAClBC,aAAc,OACdC,WAAY,QAERsE,EAAmB,eAAQD,GACjCC,EAAoB3C,YAAc,MAElC,IAAM4C,EACJ,qBAAKrG,MAAOmG,EAAkBrD,QAAS,kBAAMoD,GAAoB,IAAjE,SACE,cAAC,IAAD,MAGEI,EACJ,qBAAKtG,MAAOoG,EAAqBtD,QAAS,kBAAMoD,GAAoB,IAApE,SACE,cAAC,IAAD,MAIJ,OACE,gCACGD,EAAWnJ,KAAI,SAACyJ,EAAIC,GACnB,OACE,sBAEExG,MAAO,CACLsB,QAAS,OACTC,iBAAkB,MAClBC,oBAAqB,YACrBiF,UAAW,OACX/E,WAAY,UAPhB,UAUE,cAAC,EAAD,CACE9G,UAAW2L,EACX7L,YAAaA,EACbwI,gBAAiB,SAACzF,GAAD,OAAWyF,EAAgBsD,EAAO/I,IACnD0F,0BAA2B,SAAC7F,EAAaG,GAAd,OACzB0F,EAA0BqD,EAAOlJ,EAAaG,IAEhD2F,sBAAuB,SACrB9F,EACAoJ,EACAlJ,EACAC,GAJqB,OAMrB2F,EACEoD,EACAlJ,EACAoJ,EACAlJ,EACAC,MAIN,cAAC,EAAD,CAAe7C,UAAW2L,EAAI7L,YAAaA,MA/BtC8L,MAmCX,sBACExG,MAAO,CACLsB,QAAS,OACTC,iBAAkB,MAClBC,oBAAqB,cACrBiF,UAAW,OACXhF,aAAc,QACdC,WAAY,SACZ8C,eAAgB,QAChBP,SAAU,QATd,UAYGgC,EAAWrM,OAAS,EAAI0M,EAAiB,wBACzCL,EAAWrM,ON7ES,EM6EgByM,EAAc,wBACnD,+BC+FOM,MAjKf,YAgCE,IAhCwD,IAA5BV,EAA2B,EAA3BA,WAAYvL,EAAe,EAAfA,YAClCsB,EAAciK,EAAWnJ,KAAI,SAACyJ,GAAD,OACjC5L,EAA4B4L,EAAI7L,MAE5BkM,EAAQ3K,EAAwBD,GAChCmC,EAAYyI,EAAMxI,QACtB,SAACC,EAAD,0BAActB,GAAd,kBAAuBA,IAAOhD,IAAWsE,EAAQpE,KAAKqE,IAAID,EAAOtB,EAAK,KP5BtC,GO+B5B8J,EAAgBD,EAAM9J,KAAI,WAAY0B,GAAS,IAAD,mBAAlBsI,EAAkB,KAAb/J,EAAa,KAC5CgK,EAAkB,IAARvI,EAAY,EAAIoI,EAAMpI,EAAM,GAAG,GAC/C,OAAOzB,IAAOhD,IACV,CAAEgD,GAAIoB,EAAW2I,IAAKC,GACtB,CAAEhK,GAAIA,EAAI+J,IAAKA,MAEfE,EAAqBf,EAAW7H,QACpC,SAACC,EAAOkI,GAAR,OAAelI,EAAQkI,EAAG9L,kBAC1B,GAEIwM,EAAahN,KAAKqE,IAAI0I,EAAqB,EA1BxB,IA2BnBE,EAAiBlK,EAA6BhB,GAAac,KAC/D,SAACqK,GACC,OAAOA,EAAWrK,KAAI,YAAiC,IAAD,mBAA9BsK,EAA8B,KAAjBC,EAAiB,KACpD,OAAOD,IAAgBrN,IACnB,CAAE+M,IAAKG,EAAYK,QAASD,GAC5B,CAAEP,IAAKM,EAAaE,QAASD,SAKjCE,EAAmB,GAEhB5N,EAAI,EAAGA,GAAKsN,EAAYtN,GADL,IAE1B4N,EAAiB7N,KAAKC,GAIxB,IAFA,IAAM6N,EAAU,GAEP7N,EAAI,EAAGA,GAAKwE,EAAWxE,GADb,GAEjB6N,EAAQ9N,KAAKC,GAIf,IAFA,IAAM8N,EAAmB,GAEhB9N,EAAI,EAAGA,GPjEU,GOiESA,GADP,IAE1B8N,EAAiB/N,KAAKC,GAGxB,OACE,eAAC8E,EAAA,EAAD,CACEC,MAAO,IACPC,OAAQ,IACRvE,KAAI,mCACJwE,OAAQ,CAAEC,IAAK,EAAGC,MAAO,EAAGC,KAAM,EAAGC,OAAQ,GAJ/C,UAME,cAACC,EAAA,EAAD,IACA,cAACS,EAAA,EAAD,CACEC,KAAK,SACLC,QAAQ,MACRC,OAAQ,CAAC,EAAGoH,GACZ7H,MAAO,CAAEC,MAAO,gBAAiBC,SAAU,gBAC3CX,OAAQ,GACRvE,KAAK,gBACLsN,MAAOH,EACPI,WAAY,IAEd,cAAC5H,EAAA,EAAD,CACEJ,KAAK,SACLC,QAAQ,UACRC,OAAQ,CAAC,EAAG1B,GACZ/D,KAAK,sBACLgF,MAAO,CACLC,MAAO,sBACPC,SAAU,aACVU,MAAO,CAAEC,WAAY,UACrBC,OAAQ,IAEVxB,MAAO,GACPgJ,MAAOD,EACPG,YAAa,OACbD,WAAY,EACZE,SAAU,EACVC,QAAQ,SAEV,cAAC/H,EAAA,EAAD,CACEJ,KAAK,SACLC,QAAQ,KACRC,OAAQ,CAAC,EAAG1B,GACZ/D,KAAK,aACLgF,MAAO,CACLC,MAAO,aACPC,SAAU,cACVU,MAAO,CAAEC,WAAY,UACrBC,OAAQ,IAEVxB,MAAO,GACPgJ,MAAOF,EACPI,YAAa,QACbD,WAAY,EACZE,SAAU,EACVC,QAAQ,UAEV,cAAC3H,EAAA,EAAD,IAEA,cAACC,EAAA,EAAD,CACEhG,KAAK,aACLmE,KAAMsI,EACNtH,KAAMjG,EACN+G,KAAM,CAAEZ,YAAa,GACrBsI,MAAM,QACND,QAAQ,UAETZ,EAAepK,KAAI,SAACkL,EAAexJ,GAClC,OACE,cAAC4B,EAAA,EAAD,CAEEhG,KAAK,sBACLmE,KAAMyJ,EACNzI,KAAM0G,EAAWzH,GAAKnE,MACtBgG,KAAM,CAAEZ,YAAa,KACrBqI,QAAQ,QANV,YACYtJ,OASfyH,EAAWnJ,KAAI,SAACyJ,EAAI/H,GACnB,OACE,cAACU,EAAA,EAAD,CAEEoB,EAAGiG,EAAG9L,gBACNqN,QAAQ,OACR1I,MAAO,CACLC,MAAO,cACPE,KAAMgH,EAAGlM,MACTiF,SAAU,oBAEZH,OAAQoH,EAAGlM,MACXmF,gBAAgB,MAChBC,YAAa,GACbc,SAAS,GAZX,YACY/B,OAef9D,EAAYoC,KAAI,SAACiB,EAAUS,GAC1B,OACE,cAACU,EAAA,EAAD,CAEEoB,EAAGvC,EAASzC,aACZwM,QAAQ,QACR3I,OAAQ7F,EACR8F,MAAO,CACLC,MAAOtB,EAAS3D,KAAO,UACvBkF,SAAU,iBACVC,KAAMjG,GAERkG,gBAAgB,MAChBC,YAAa,IAXf,eACejB,WC5GVyJ,MAzDf,YAIE,IAJ8C,IAAhBvN,EAAe,EAAfA,YAExB+J,EAAU,CAAC,mBAAoB,cAC/ByD,EAAU,GACPvO,EAAI,EAAGA,EAAIe,EAAYd,OAAQD,IAAK,CAC3CuO,EAAQxO,KAAKgB,EAAYf,GAAGS,MAC5B,IAAM+N,EAAe,IAANxO,EAAU,EAAIe,EAAYf,EAAI,GAAG2B,aAC1CyB,EAAKrC,EAAYf,GAAG2B,aAC1B4M,EAAQxO,KAAR,UAAgByO,EAAhB,YAA0BpL,IAAOhD,IAAW,SAAWgD,IAIzD,IAAMkE,EAAc,kBACdqC,EAAa,CACjBC,UAAWtC,EACX+B,WAAY/B,GAERmH,EAAa,CACjBrF,QAAS,QACT5B,aAAcF,EACdG,YAAaH,EACbI,UAAW,UAEPsC,EAAW,eAAQyE,GACzBzE,EAAYC,WAAa,OAGzB,IADA,IAAMyE,EAAO,GACJ1O,EAAI,EAAGA,EAAI8K,EAAQ7K,OAAQD,GAAK,EACvC0O,EAAK3O,KACH,qBAAmBsG,MAAO2D,EAA1B,SACGc,EAAQ9K,IADX,WAAcA,KAKlB,IAAK,IAAIA,EAAI,EAAGA,EAAIuO,EAAQtO,OAAQD,GAAK,EACvC0O,EAAK3O,KACH,qBAAmBsG,MAAOoI,EAA1B,SACGF,EAAQvO,IADX,WAAcA,KAMlB,OACE,qBAAKqG,MAAOsD,EAAZ,SACE,qBACEtD,MAAO,CACLsB,QAAS,OACTC,iBAAiB,UAAD,OAAY7G,EAAYd,OAAS,EAAjC,UAChB4H,oBAAqB,aAJzB,SAOG6G,EAAKvL,KAAI,SAACiJ,GAAD,OAASA,UCnCduC,EAAsB,WACjC,IAAMC,EAAMpO,EAAmB,aAAc,UAAW,GAAI,GAG5D,OAFAoO,EAAI7N,YAAY,GAAG,GAAK,CAAC,GAAI,IAC7B6N,EAAI7N,YAAY,GAAGhB,KAAK,CAACK,IAAU,IAC5BwO,GAIIC,EAAsB,WACjC,IAAMC,EAAMtO,EAAmB,aAAc,UAAW,GAAI,GAG5D,OAFAsO,EAAI/N,YAAY,GAAG,GAAK,CAAC,GAAI,IAC7B+N,EAAI/N,YAAY,GAAG,GAAG,GAAK,GACpB+N,GCfHC,EAAW,CACf,UACA,UACA,UACA,UACA,UACA,WAkJaC,MA/If,WAAe,MAM4BC,YDpBI,CAC7C,CAAExO,KAAM,aAAckB,aAAc,GACpC,CAAElB,KAAM,cAAekB,aAAcvB,OCYxB,mBAMNW,EANM,aAS0BkO,YAAS,CAC9CN,IACAE,OAXW,mBASNvC,EATM,KASM4C,EATN,KA6GPC,EAAoB,CACxBxH,QAAS,OACTC,iBAAkB,YAClBC,oBAAqB,OACrBuH,OAAQ,OACRtH,aAAc,SACdC,WAAY,SACZ8C,eAAgB,UAIZwE,EAA+BF,EAErC,OACE,sBAAK9I,MA3Bc,CACnBsB,QAAS,OACTC,iBAAkB,MAClBC,oBAAqB,YACrBiF,UAAW,OACXhF,aAAc,QACdC,WAAY,SACZ8C,eAAgB,QAChByE,WAAY,OACZC,UAAW,QAkBX,UACE,sBAAKlJ,MAAO8I,EAAZ,UACE,cAAC,EAAD,CAAsBpO,YAAaA,IACnC,cAAC,EAAD,CACEuL,WAAYA,EACZvL,YAAaA,EACbwI,gBA/FsB,SAACsD,EAAO2C,GACpCN,GAAiB,SAACO,GAChB,IAAM7C,EAAK6C,EAAS5C,GAChB2C,EACE5C,EAAG9L,gBVzDa,KUyDmB8L,EAAG9L,iBAAmB,GAEzD8L,EAAG9L,gBAAkB,IAAG8L,EAAG9L,iBAAmB,OA0FhD0I,0BArF0B,SAACqD,EAAOlJ,EAAa6L,GACrDN,GAAiB,SAACO,GAChB,IAAM7C,EAAK6C,EAAS5C,GACd6C,EAAY/L,IAAgBiJ,EAAG7L,YAAYd,OAAS,EACpD0P,EAAK/C,EAAG7L,YAAY4C,GACpBiM,EAAID,EAAG1P,OAGb,IAAKuP,EAAa,CAChB,GAAII,EAAI,EAAG,OAGX,OAFAD,EAAGE,WACCH,IAAWC,EAAGC,EAAI,GAAG,GAAKxP,MAKhC,GAAU,IAANwP,EACFD,EAAG5P,KAAK,CAAC2P,EAAYtP,IAAW,EAAG,QAC9B,CAAC,IAAD,cACmBuP,EAAGC,EAAI,GAD1B,GACEE,EADF,KACUC,EADV,KAELJ,EAAG5P,KAAK,CAAC+P,EAAQC,IACbL,IAEFC,EAAGC,EAAI,GAAG,GAAW,IAANA,EAAU,EAAID,EAAGC,EAAI,GAAG,SA+DvCnG,sBAzDsB,SAC5BoD,EACAlJ,EACAoJ,EACAlJ,EACA2L,GAEAN,GAAiB,SAACO,GAChB,IACME,EADKF,EAAS5C,GACN9L,YAAY4C,GAAaoJ,GACnCyC,EACE3L,EAAU8L,EAAG,IAAM,EAClBA,EAAG,IAAM,EAEV9L,EAAU8L,EAAG,IAAM,EAClBA,EAAG,IAAM,MA2CZpD,oBAtHoB,SAACiD,GAC3BN,GAAiB,SAACO,GAChB,IAAM5K,EAAM4K,EAASxP,OACrB,GAAIuP,EAAa,CACf,GV9BqB,IU8BjB3K,EAAuB,OAC3B4K,EAAS1P,KACPS,EAAmB,YAAD,OACJqE,EAAM,GAClBkK,EAASlK,GACT,EACA9D,EAAYd,aAGX,CACL,GAAY,IAAR4E,EAAW,OACf4K,EAASI,gBA0GX,sBAAKxJ,MAAOgJ,EAAZ,UACE,qBAAKhJ,MAAO,CAAEiE,SAAU,QAAxB,4CACA,cAAC,EAAD,CAAoBgC,WAAYA,EAAYvL,YAAaA,WC5JjEiP,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.008d64df.chunk.js","sourcesContent":["//max values to display in plots\r\nexport const plotBwCutoff = 25;\r\nexport const plotBaseMaxFairShare = 5;\r\n\r\n//max estimated demand for a flow group\r\nexport const maxEstDemand = 20;\r\nexport const weightLimit = 100;\r\nexport const bandwidthLimit = 100;\r\nexport const maxNumWeightThresholds = 5;\r\n\r\nexport const fairShareColor = \"red\";\r\n\r\nexport const maxFlowGroups = 6;\r\n","//given a list of 2+ points [x,y], remove duplicated points anad points aligned with the previous and next points\r\n//points are assumed ordered such that each point is larger in at least one of the coordinates than the previous\r\n//last point can have Infinity as coordinates\r\nexport const removeFlatPoints = (points) => {\r\n  const P = []; //unique points\r\n  P.push(points[0]);\r\n  for (let i = 1; i < points.length; i += 1) {\r\n    if (points[i][0] === points[i - 1][0] && points[i][1] === points[i - 1][1])\r\n      continue; //repeated point\r\n    P.push(points[i]);\r\n  }\r\n  const res = [];\r\n  res.push(P[0]);\r\n  for (let i = 1; i < P.length - 1; i += 1) {\r\n    if (P[i - 1][0] === P[i + 1][0]) continue; //middle of vertical segment\r\n    if (P[i - 1][0] === P[i][0] || P[i][0] === P[i + 1][0]) {\r\n      //start or end of vertical segment\r\n      res.push(P[i]);\r\n      continue;\r\n    }\r\n    const slope1 = (P[i][1] - P[i - 1][1]) / (P[i][0] - P[i - 1][0]);\r\n    if (P[i + 1][0] === Infinity) {\r\n      if (slope1 !== 0) res.push(P[i]);\r\n    } else if (P[i + 1][1] === Infinity) {\r\n      res.push(P[i]);\r\n    } else {\r\n      const slope2 = (P[i + 1][1] - P[i][1]) / (P[i + 1][0] - P[i][0]);\r\n      //handle floating point precission errors\r\n      if (Math.abs(slope1 - slope2) > 0.0000001) {\r\n        res.push(P[i]);\r\n      }\r\n    }\r\n  }\r\n  res.push(P[P.length - 1]);\r\n  return res;\r\n};\r\n\r\nexport const linearInterpolationY = (x, [x0, y0], [x1, y1]) => {\r\n  return y0 + ((x - x0) * (y1 - y0)) / (x1 - x0);\r\n};\r\n","import { removeFlatPoints, linearInterpolationY } from \"./utils\";\r\n\r\n/*A flow group has a name, an estimated demand, an (arbitrary) display color,\r\nand, most importantly, the bandwidth requirements for each allocation level:\r\nFor each allocation level, there is a list of weight thresholds.\r\nEach weight threshold is a pair of values [bandwidth, weight].\r\n* If the flow group requires no bandwidth in an allocation level, there should be a single pair [0,0].\r\n* Otherwise, it should contain 1+ pairs where:\r\n-- bandwidth values (meaning cumulative bandwidth for that allocation level) must be increasing\r\n-- weight values must be decreasing\r\nIn addition, the last requirement for the last (least prioritary) allocation level\r\nshould be infinite, since the estimated demand of the flow group is what should\r\nultimately limit how much bandwidth can be allocated to a flow group.\r\n\r\nThe bandwidth requested for each allocation level must be completely allocatable\r\nby the point fair share reaches the transition to the next allocation level.\r\nFor now, the slope of bandwidth functions is equal to the weight, so a bandwidth\r\nfunction could be invalid if the required bandwidth is too high (equivalently, if the weight is too low)\r\nFor example, 2.5 bandwidth with weight 1 would be too much for an allocation level with a range of 0-2 fair share.\r\n(the alternative would be to make the slope a multiple of the weight that changes automatically\r\nbut, for the sake of visualization, I think weight=slope is more useful)\r\n*/\r\n\r\n/* Makes a flow group with no bandwidth requirements \r\n(except the bandwidth for the last (least prioritary) allocation level, which is infinite) */\r\nexport const makeEmptyFlowGroup = (name, color, estBandwidth, numAllocLvls) => {\r\n  const allocLvls = [];\r\n  for (let i = 0; i < numAllocLvls - 1; i++) allocLvls[i] = [[0, 0]];\r\n  allocLvls.push([[Infinity, 0]]);\r\n  return {\r\n    name: name,\r\n    color: color,\r\n    estimatedDemand: estBandwidth,\r\n    allocLevels: allocLvls,\r\n  };\r\n};\r\n\r\n/* given the requirements for a flow group and the transition points between allocation \r\nlevels, returns the bandwidth function (as defined in the paper) for the flow group\r\nThe bandwidth function is returned as an ordered list of points [fair share, bandwidth],\r\nwhere the last point has infinite fair share */\r\nexport const bandwidthFunctionDataPoints = (flowGroup, allocLevels) => {\r\n  const res = [];\r\n  let [accumFs, accumBw] = [0, 0];\r\n  const fgConfig = flowGroup.allocLevels;\r\n  for (let i = 0; i < allocLevels.length; i++) {\r\n    res.push([accumFs, accumBw]);\r\n    let prevBw = 0; //bw starts at 0 for each alloc level\r\n    for (let j = 0; j < fgConfig[i].length; j++) {\r\n      let [bw, weight] = fgConfig[i][j];\r\n      let bwIncrement = Math.min(\r\n        bw - prevBw,\r\n        flowGroup.estimatedDemand - accumBw //bw functions cannot exceed est. demand\r\n      );\r\n      prevBw = bw;\r\n      if (weight > 0) {\r\n        accumFs += bwIncrement / weight;\r\n        accumBw += bwIncrement;\r\n        res.push([accumFs, accumBw]);\r\n      }\r\n    }\r\n    //regardless of the used fair share, the next allocation level starts at this specific fair share\r\n    accumFs = allocLevels[i].maxFairShare;\r\n  }\r\n  res.push([Infinity, accumBw]);\r\n  return removeFlatPoints(res);\r\n};\r\n\r\n/* Given a bandwidth function (ordered list of pairs [fair share, bandwidth]) and a fair share value,\r\nreturns the allocated bandwidth at that given fair share value.\r\nAs mentioned in the paper, this could easily be optimized with binary search */\r\nconst allocatedBandwidth = (bwFunc, fairShare) => {\r\n  if (fairShare === Infinity) return bwFunc[bwFunc.length - 1][1];\r\n\r\n  let i = 0;\r\n  //does not go out of bounds because the last fair share is infinite\r\n  while (bwFunc[i][0] < fairShare) i++;\r\n\r\n  if (bwFunc[i][0] === fairShare) return bwFunc[i][1];\r\n  if (bwFunc[i][0] === Infinity) return bwFunc[i][1]; //bw function is always flat in last segment\r\n  return linearInterpolationY(fairShare, bwFunc[i - 1], bwFunc[i]);\r\n};\r\n\r\n/* Given a list of bandwidth functions and a fair share value, returns the total\r\nallocated bandwidth between the bandwidth functions at that given fair share value. */\r\nconst totalAllocatedBandwidth = (bwFunctions, fairShare) => {\r\n  let res = 0;\r\n  for (let i = 0; i < bwFunctions.length; i++) {\r\n    res += allocatedBandwidth(bwFunctions[i], fairShare);\r\n  }\r\n  return res;\r\n};\r\n\r\n/* Given a list of bandwidth functions, returns, in order, all the unique fair share values\r\nwhere one of the functions has a linear-piece endpoint, including Infinity as the last value */\r\nconst fairShareValues = (bwFuncs) => {\r\n  const fsValues = new Set();\r\n  for (let i = 0; i < bwFuncs.length; i++) {\r\n    for (let j = 0; j < bwFuncs[i].length; j++) {\r\n      fsValues.add(bwFuncs[i][j][0]);\r\n    }\r\n  }\r\n  const res = Array.from(fsValues);\r\n  res.sort((a, b) => a - b); //sort by value instead of lexicographical order\r\n  console.assert(res[res.length - 1] === Infinity);\r\n  return res;\r\n};\r\n\r\n/* Given a list of bandwidth functions, returns the aggregated fair share function\r\nas a function of the available capacity of a link shared by all the flow groups.\r\nThe aggregated fair share function is returned as a sorted list of points [link cap, fair share].\r\n\r\nThe following observation gives us the list of candidate points to consider:\r\nall the linear-piece endpoints of the aggregated fair share function must also be \r\na linear-piece endpoint of one of the bandwidth functions. */\r\nexport const linkFairShareDataPoints = (bwFunctions) => {\r\n  const fsValues = fairShareValues(bwFunctions);\r\n  const res = fsValues.map((fs) => [\r\n    totalAllocatedBandwidth(bwFunctions, fs),\r\n    fs,\r\n  ]);\r\n  return removeFlatPoints(res);\r\n};\r\n\r\n/* Given a list of bandwidth functions, returns the allocated bandwidth function for each\r\nof them as a function of the available capacity of a link shared by all the flow groups.\r\nEach allocated bandwidth function is returned as an ordered list of pairs [link cap, allocated bw] */\r\nexport const allocatedBandwidthDataPoints = (bwFuncs) => {\r\n  const linkCapFsPairs = linkFairShareDataPoints(bwFuncs);\r\n\r\n  const allocatedBwSingleFg = (bwFunc) => {\r\n    const res = linkCapFsPairs.map(([linkCap, fs]) => [\r\n      linkCap,\r\n      allocatedBandwidth(bwFunc, fs),\r\n    ]);\r\n    //last point: link with infinite cap, the allocated bw is the same as the previous point\r\n    res.push([Infinity, res[res.length - 1][1]]);\r\n\r\n    return removeFlatPoints(res);\r\n  };\r\n\r\n  return bwFuncs.map((bwFunc) => allocatedBwSingleFg(bwFunc));\r\n};\r\n\r\n/* Given the list of weight thresholds for the bandwidth requirements of a flow group\r\nfor a specific allocation level, returns the amount of fair share needed by the flow\r\ngroup to allocate all the required bandwidth in that allocation level.\r\n\r\nAssumes that in the bandwidth function, slope = weight, where slope = (required bw / fair share)\r\nin each linear segment, so the total fair share is the sum, over all the segments, of required bandwidth / weight */\r\nconst neededFairshare = (thresholds) => {\r\n  //the last allocation level always demands infinite bandwidth, which requires infinite fair share\r\n  if (thresholds[thresholds.length - 1][0] === Infinity) return Infinity;\r\n  let accumFs = 0;\r\n  let prevBw = 0;\r\n  for (let i = 0; i < thresholds.length; i++) {\r\n    let [bw, weight] = thresholds[i];\r\n    let bwIncrement = bw - prevBw;\r\n    prevBw = bw;\r\n    if (weight > 0) {\r\n      accumFs += bwIncrement / weight;\r\n    }\r\n  }\r\n  return accumFs;\r\n};\r\n\r\n/* Given a list of allocation levels and an index, returns the span (max - min) of fair share\r\nfor the allocation level at that index */\r\nconst fairShareSpan = (allocationLevels, allocLvlIdx) => {\r\n  //the last allocation level goes to infinite fair share\r\n  if (allocLvlIdx === allocationLevels.length - 1) return Infinity;\r\n  const allocLvl = allocationLevels[allocLvlIdx];\r\n  if (allocLvlIdx === 0) return allocLvl.maxFairShare;\r\n  return allocLvl.maxFairShare - allocationLevels[allocLvlIdx - 1].maxFairShare;\r\n};\r\n\r\n/* As discussed at the top of this file, some bandwidth/weight combinations in a flow group \r\nconfiguration are invalid because there would be not enough fair share in an allocation level.\r\nThis function checks if increasing or decreasing the bandwidth or weight of a threshold would make\r\nthe configuration of a flow group invalid */\r\nexport const thresholdChangeViolatesFairShareSpan = (\r\n  flowGroup,\r\n  allocationLevels,\r\n  allocLvlIdx,\r\n  thresholdIdx,\r\n  isWeight,\r\n  isInc\r\n) => {\r\n  //make a (deep) copy of the thresholds in the modified allocation level\r\n  let modifiedThresholdList = flowGroup.allocLevels[allocLvlIdx].map((p) => [\r\n    ...p,\r\n  ]);\r\n  const modifiedIdx = isWeight ? 1 : 0;\r\n  modifiedThresholdList[thresholdIdx][modifiedIdx] += isInc ? 1 : -1;\r\n  return (\r\n    neededFairshare(modifiedThresholdList) >\r\n    fairShareSpan(allocationLevels, allocLvlIdx)\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport {\r\n  ScatterChart,\r\n  Scatter,\r\n  CartesianGrid,\r\n  XAxis,\r\n  YAxis,\r\n  Tooltip,\r\n  ReferenceLine,\r\n} from \"recharts\";\r\nimport { plotBwCutoff, plotBaseMaxFairShare, fairShareColor } from \"./globals\";\r\nimport { bandwidthFunctionDataPoints } from \"./fairShareLogic\";\r\n\r\nfunction BandwidthPlot({ flowGroup, allocLevels }) {\r\n  const pts = bandwidthFunctionDataPoints(flowGroup, allocLevels); //points [fs, bw]\r\n  const plotMaxFs = pts.reduce(\r\n    (accum, [fs, bw]) => (fs === Infinity ? accum : Math.max(accum, fs + 1)),\r\n    plotBaseMaxFairShare\r\n  );\r\n  const data = pts.map(([fs, bw], idx) => {\r\n    const prevBw = idx === 0 ? 0 : pts[idx - 1][1];\r\n    console.assert(fs !== Infinity || bw === prevBw, bw, prevBw);\r\n    return fs === Infinity ? { fs: plotMaxFs, bw: prevBw } : { fs: fs, bw: bw };\r\n  });\r\n\r\n  //documentation: http://recharts.org/en-US/examples/JointLineScatterChart\r\n  return (\r\n    <ScatterChart\r\n      width={420}\r\n      height={230}\r\n      name={`${flowGroup.name} bandwidth function`}\r\n      margin={{ top: 5, right: 5, left: 5, bottom: 5 }}\r\n    >\r\n      <CartesianGrid />\r\n      {allocLevels.map((allocLvl, idx) => {\r\n        return (\r\n          <ReferenceLine\r\n            key={idx}\r\n            x={allocLvl.maxFairShare}\r\n            stroke={fairShareColor}\r\n            label={{\r\n              value: allocLvl.name + \" alloc.\",\r\n              position: \"insideTopRight\",\r\n              fill: fairShareColor,\r\n            }}\r\n            strokeDasharray=\"3 3\"\r\n            strokeWidth={0.8}\r\n          />\r\n        );\r\n      })}\r\n\r\n      <XAxis\r\n        type=\"number\"\r\n        dataKey=\"fs\"\r\n        domain={[0, plotBaseMaxFairShare]}\r\n        name=\"Fair Share\"\r\n        label={{ value: \"Fair Share\", position: \"insideBottom\" }}\r\n        height={40}\r\n        tickCount={11}\r\n      />\r\n      <YAxis\r\n        type=\"number\"\r\n        dataKey=\"bw\"\r\n        name=\"Bandwidth\"\r\n        label={{\r\n          value: \"Allocated Bandwidth\",\r\n          position: \"insideLeft\",\r\n          style: { textAnchor: \"middle\" },\r\n          angle: -90,\r\n        }}\r\n        width={40}\r\n        domain={[0, plotBwCutoff]}\r\n        tickCount={6}\r\n      />\r\n      <Tooltip />\r\n      {/* <Legend /> */}\r\n      <Scatter\r\n        name=\"Fair Share\"\r\n        data={data}\r\n        fill={flowGroup.color}\r\n        line={{ strokeWidth: 2.5 }}\r\n      />\r\n      <ReferenceLine\r\n        y={flowGroup.estimatedDemand}\r\n        label={{\r\n          value: \"Est. demand\",\r\n          fill: flowGroup.color,\r\n          position: \"insideBottomRight\",\r\n        }}\r\n        stroke={flowGroup.color}\r\n        strokeDasharray=\"3 3\"\r\n        strokeWidth={0.8}\r\n        isFront={true}\r\n      />\r\n    </ScatterChart>\r\n  );\r\n}\r\n\r\nexport default BandwidthPlot;\r\n","import React, { useState } from \"react\";\r\n\r\nfunction IncrementableButton({\r\n  value,\r\n  text,\r\n  min,\r\n  max,\r\n  onDec,\r\n  onInc,\r\n  width,\r\n  thickBottom,\r\n  thickRight,\r\n  disabled,\r\n  disabledInc,\r\n  disabledDec,\r\n}) {\r\n  const borderStyle = \"1px solid black\";\r\n  const thickBorderStyle = \"2px solid black\";\r\n  const style = {\r\n    borderBottom: thickBottom ? thickBorderStyle : borderStyle,\r\n    borderRight: thickRight ? thickBorderStyle : borderStyle,\r\n    textAlign: \"center\",\r\n    display: \"grid\",\r\n    gridTemplateRows: \"auto\",\r\n    gridTemplateColumns: `16px ${width - 16 * 2}px 16px`,\r\n    justifyItems: \"stretch\",\r\n    alignItems: \"stretch\",\r\n    MozUserSelect: \"none\",\r\n    WebkitUserSelect: \"none\",\r\n    msUserSelect: \"none\",\r\n    userSelect: \"none\",\r\n  };\r\n  const [hoveredMin, setHoveredMin] = useState(false);\r\n  const [hoveredMax, setHoveredMax] = useState(false);\r\n\r\n  const buttonBgCol = \"#e5e5e5\";\r\n  const hoveredBgCol = \"#d0d0d0\";\r\n  const valueBgCol = \"#f6f6f6\";\r\n  const disabledButtonBgCol = \"#fafafa\";\r\n  const disabledButtonTextCol = \"#a5a5a5\";\r\n\r\n  const incDisabled = disabled || disabledInc || value + 1 > max;\r\n  const decDisabled = disabled || disabledDec || value - 1 < min;\r\n\r\n  return (\r\n    <div style={style}>\r\n      <div\r\n        style={{\r\n          borderRight: borderStyle,\r\n          color: decDisabled ? disabledButtonTextCol : \"black\",\r\n          backgroundColor: decDisabled\r\n            ? disabledButtonBgCol\r\n            : hoveredMin\r\n            ? hoveredBgCol\r\n            : buttonBgCol,\r\n          cursor: decDisabled ? \"not-allowed\" : \"pointer\",\r\n        }}\r\n        onMouseEnter={() => setHoveredMin(true)}\r\n        onMouseLeave={() => setHoveredMin(false)}\r\n        onClick={() => {\r\n          if (!decDisabled) onDec();\r\n        }}\r\n      >\r\n        -\r\n      </div>\r\n      <div\r\n        style={{\r\n          backgroundColor: valueBgCol,\r\n          alignItems: \"stretch\",\r\n          padding: \"0.2em\",\r\n        }}\r\n      >\r\n        {text ? text : value === Infinity ? \"\\u221E\" : value}\r\n      </div>\r\n      <div\r\n        style={{\r\n          borderLeft: borderStyle,\r\n          borderRight: thickRight ? thickBorderStyle : borderStyle,\r\n          color: incDisabled ? disabledButtonTextCol : \"black\",\r\n          backgroundColor: incDisabled\r\n            ? disabledButtonBgCol\r\n            : hoveredMax\r\n            ? hoveredBgCol\r\n            : buttonBgCol,\r\n          cursor: incDisabled ? \"not-allowed\" : \"pointer\",\r\n        }}\r\n        onMouseEnter={() => setHoveredMax(true)}\r\n        onMouseLeave={() => setHoveredMax(false)}\r\n        onClick={() => {\r\n          if (!incDisabled) onInc();\r\n        }}\r\n      >\r\n        +\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default IncrementableButton;\r\n","import React from \"react\";\r\nimport { IoIosAddCircleOutline, IoIosCloseCircleOutline } from \"react-icons/io\";\r\nimport {\r\n  maxEstDemand,\r\n  weightLimit,\r\n  bandwidthLimit,\r\n  maxNumWeightThresholds,\r\n} from \"./globals\";\r\nimport { thresholdChangeViolatesFairShareSpan } from \"./fairShareLogic\";\r\n\r\nimport IncrementableButton from \"./IncrementableButton\";\r\n\r\nfunction FlowConfigTable({\r\n  flowGroup,\r\n  allocLevels,\r\n  handleEstDemand,\r\n  handleNumWeightThresholds,\r\n  handleWeightThreshold,\r\n}) {\r\n  const totalWidth = 320;\r\n  const buttonWidth = 90;\r\n\r\n  const borderStyle = \"1px solid black\";\r\n  const thickBorderStyle = \"2px solid black\";\r\n  const tableStyle = {\r\n    borderTop: thickBorderStyle,\r\n    borderLeft: thickBorderStyle,\r\n  };\r\n  const cellStyle = {\r\n    borderBottom: borderStyle,\r\n    borderRight: borderStyle,\r\n    textAlign: \"center\",\r\n    justifySelf: \"stretch\",\r\n    alignSelf: \"stretch\",\r\n  };\r\n  const headerStyle = { ...cellStyle };\r\n  headerStyle.fontWeight = \"bold\";\r\n  headerStyle.padding = \"0.2rem\";\r\n  headerStyle.borderBottom = thickBorderStyle;\r\n  const topHeaderStyle = { ...headerStyle };\r\n  topHeaderStyle.color = flowGroup.color;\r\n  topHeaderStyle.borderRight = thickBorderStyle;\r\n\r\n  const allocLvlDivStyle = { ...cellStyle };\r\n  allocLvlDivStyle.display = \"grid\";\r\n  allocLvlDivStyle.gridTemplateRows = \"auto\";\r\n  allocLvlDivStyle.gridTemplateColumns = \"1fr 20px 20px\";\r\n  allocLvlDivStyle.alignItems = \"center\";\r\n  const allocTextDivStyle = { justifySelf: \"start\" };\r\n  const weightThresholdButtonStyle = {\r\n    cursor: \"pointer\",\r\n    MozUserSelect: \"none\",\r\n    WebkitUserSelect: \"none\",\r\n    msUserSelect: \"none\",\r\n    userSelect: \"none\",\r\n    fontSize: \"18px\",\r\n    paddingTop: \"0.2rem\",\r\n  };\r\n\r\n  const topHeader = `${flowGroup.name}`;\r\n  const topHeaderDiv = <div style={topHeaderStyle}>{topHeader}</div>;\r\n\r\n  const estBwDiv = <div style={headerStyle}>Est. Bandwidth</div>;\r\n  const estBwButton = (\r\n    <IncrementableButton\r\n      value={flowGroup.estimatedDemand}\r\n      min={0}\r\n      max={maxEstDemand}\r\n      onInc={() => {\r\n        handleEstDemand(true);\r\n      }}\r\n      onDec={() => {\r\n        handleEstDemand(false);\r\n      }}\r\n      width={buttonWidth}\r\n      thickBottom\r\n      thickRight\r\n    />\r\n  );\r\n  const estBwRow = (\r\n    <div\r\n      style={{\r\n        display: \"grid\",\r\n        gridTemplateRows: `1fr`,\r\n        gridTemplateColumns: `1fr ${buttonWidth}px`,\r\n        justifyItems: \"stretch\",\r\n        alignItems: \"stretch\",\r\n        justifyContent: \"stretch\",\r\n        width: `${totalWidth}px`,\r\n      }}\r\n    >\r\n      {estBwDiv}\r\n      {estBwButton}\r\n    </div>\r\n  );\r\n\r\n  const headers = [\"Allocation level\", \"Weight\", \"Bandwidth\"];\r\n  const headerDivs = headers.map((text, idx) => {\r\n    const sty = { ...headerStyle };\r\n    if (idx === headers.length - 1) sty.borderRight = thickBorderStyle;\r\n    return (\r\n      <div key={`h${idx}`} style={sty}>\r\n        {text}\r\n      </div>\r\n    );\r\n  });\r\n\r\n  const entryDivs = [];\r\n  let rowCount = 1;\r\n  for (let i = 0; i < allocLevels.length; i++) {\r\n    rowCount += flowGroup.allocLevels[i].length;\r\n    const addWeightThresholdButton = (\r\n      <div\r\n        style={weightThresholdButtonStyle}\r\n        onClick={() => handleNumWeightThresholds(i, true)}\r\n      >\r\n        <IoIosAddCircleOutline />\r\n      </div>\r\n    );\r\n    const removeWeightThesholdButton = (\r\n      <div\r\n        style={weightThresholdButtonStyle}\r\n        onClick={() => handleNumWeightThresholds(i, false)}\r\n      >\r\n        <IoIosCloseCircleOutline />\r\n      </div>\r\n    );\r\n    for (let j = 0; j < flowGroup.allocLevels[i].length; j++) {\r\n      const isFirst = j === 0;\r\n      const isLast = j === flowGroup.allocLevels[i].length - 1;\r\n      const removeButtonHere = isLast && !isFirst;\r\n      const addButtonHere = isLast && j < maxNumWeightThresholds;\r\n      const [bw, weight] = flowGroup.allocLevels[i][j];\r\n      const allocLvlText = isFirst ? allocLevels[i].name : \"\";\r\n      const divStyle = { ...allocLvlDivStyle };\r\n      if (!isLast) {\r\n        divStyle.borderBottom = undefined;\r\n      } else {\r\n        divStyle.borderBottom = thickBorderStyle;\r\n      }\r\n      const allocLvlDiv = (\r\n        <div key={`a${i}_${j}`} style={divStyle}>\r\n          <div style={allocTextDivStyle}>{allocLvlText}</div>\r\n          {removeButtonHere ? removeWeightThesholdButton : <div></div>}\r\n          {addButtonHere ? addWeightThresholdButton : <div></div>}\r\n        </div>\r\n      );\r\n      const maxW = isFirst ? weightLimit : flowGroup.allocLevels[i][j - 1][1];\r\n      const minW = isLast ? 0 : flowGroup.allocLevels[i][j + 1][1];\r\n      const weightButton = (\r\n        <IncrementableButton\r\n          key={`w${i}_${j}`}\r\n          value={weight}\r\n          min={minW}\r\n          max={maxW}\r\n          onInc={() => {\r\n            handleWeightThreshold(i, j, true, true);\r\n          }}\r\n          onDec={() => {\r\n            handleWeightThreshold(i, j, true, false);\r\n          }}\r\n          disabledInc={thresholdChangeViolatesFairShareSpan(\r\n            flowGroup,\r\n            allocLevels,\r\n            i,\r\n            j,\r\n            true,\r\n            true\r\n          )}\r\n          disabledDec={thresholdChangeViolatesFairShareSpan(\r\n            flowGroup,\r\n            allocLevels,\r\n            i,\r\n            j,\r\n            true,\r\n            false\r\n          )}\r\n          width={buttonWidth}\r\n          thickBottom={isLast}\r\n        />\r\n      );\r\n      const maxBw = isLast\r\n        ? bandwidthLimit\r\n        : flowGroup.allocLevels[i][j + 1][0];\r\n      const minBw = isFirst ? 0 : flowGroup.allocLevels[i][j - 1][0];\r\n      const bwButton = (\r\n        <IncrementableButton\r\n          key={`b${i}_${j}`}\r\n          value={bw}\r\n          text={\r\n            <span>\r\n              <span style={{ color: \"gray\" }}>{`${minBw}-`}</span>\r\n              <span>{`${bw === Infinity ? \"\\u221E\" : bw}`}</span>\r\n            </span>\r\n          }\r\n          min={minBw}\r\n          max={maxBw}\r\n          onInc={() => {\r\n            handleWeightThreshold(i, j, false, true);\r\n          }}\r\n          onDec={() => {\r\n            handleWeightThreshold(i, j, false, false);\r\n          }}\r\n          disabled={bw === Infinity || weight === 0}\r\n          disabledInc={thresholdChangeViolatesFairShareSpan(\r\n            flowGroup,\r\n            allocLevels,\r\n            i,\r\n            j,\r\n            false,\r\n            true\r\n          )}\r\n          disabledDec={thresholdChangeViolatesFairShareSpan(\r\n            flowGroup,\r\n            allocLevels,\r\n            i,\r\n            j,\r\n            false,\r\n            false\r\n          )}\r\n          width={buttonWidth}\r\n          thickBottom={isLast}\r\n          thickRight\r\n        />\r\n      );\r\n      entryDivs.push(allocLvlDiv);\r\n      entryDivs.push(weightButton);\r\n      entryDivs.push(bwButton);\r\n    }\r\n  }\r\n  const entryRows = (\r\n    <div\r\n      style={{\r\n        display: \"grid\",\r\n        gridTemplateRows: `repeat(${rowCount}, 1fr)`,\r\n        gridTemplateColumns: `1fr ${buttonWidth}px ${buttonWidth}px`,\r\n        justifyItems: \"stretch\",\r\n        alignItems: \"stretch\",\r\n        justifyContent: \"stretch\",\r\n        width: `${totalWidth}px`,\r\n      }}\r\n    >\r\n      {headerDivs.map((div) => div)}\r\n      {entryDivs.map((div) => div)}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <div style={tableStyle}>\r\n      {topHeaderDiv}\r\n      {estBwRow}\r\n      {entryRows}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FlowConfigTable;\r\n","import React from \"react\";\r\nimport BandwidthPlot from \"./BandwidthPlot\";\r\nimport FlowConfigTable from \"./FlowConfigTable\";\r\nimport { IoIosAddCircleOutline, IoIosCloseCircleOutline } from \"react-icons/io\";\r\nimport { maxFlowGroups } from \"./globals\";\r\n\r\nfunction FlowGroupList({\r\n  flowGroups,\r\n  allocLevels,\r\n  handleEstDemand,\r\n  handleNumWeightThresholds,\r\n  handleWeightThreshold,\r\n  handleNumFlowGroups,\r\n}) {\r\n  const addFgButtonStyle = {\r\n    justifySelf: \"start\",\r\n    cursor: \"pointer\",\r\n    MozUserSelect: \"none\",\r\n    WebkitUserSelect: \"none\",\r\n    msUserSelect: \"none\",\r\n    userSelect: \"none\",\r\n  };\r\n  const removeFgButtonStyle = { ...addFgButtonStyle };\r\n  removeFgButtonStyle.justifySelf = \"end\";\r\n\r\n  const addFgButton = (\r\n    <div style={addFgButtonStyle} onClick={() => handleNumFlowGroups(true)}>\r\n      <IoIosAddCircleOutline />\r\n    </div>\r\n  );\r\n  const removeFgButton = (\r\n    <div style={removeFgButtonStyle} onClick={() => handleNumFlowGroups(false)}>\r\n      <IoIosCloseCircleOutline />\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      {flowGroups.map((fg, fgIdx) => {\r\n        return (\r\n          <div\r\n            key={fgIdx}\r\n            style={{\r\n              display: \"grid\",\r\n              gridTemplateRows: \"1fr\",\r\n              gridTemplateColumns: \"auto auto\",\r\n              columnGap: \"10px\",\r\n              alignItems: \"center\",\r\n            }}\r\n          >\r\n            <FlowConfigTable\r\n              flowGroup={fg}\r\n              allocLevels={allocLevels}\r\n              handleEstDemand={(isInc) => handleEstDemand(fgIdx, isInc)}\r\n              handleNumWeightThresholds={(allocLvlIdx, isInc) =>\r\n                handleNumWeightThresholds(fgIdx, allocLvlIdx, isInc)\r\n              }\r\n              handleWeightThreshold={(\r\n                allocLvlIdx,\r\n                weightThresholdIdx,\r\n                isWeight,\r\n                isInc\r\n              ) =>\r\n                handleWeightThreshold(\r\n                  fgIdx,\r\n                  allocLvlIdx,\r\n                  weightThresholdIdx,\r\n                  isWeight,\r\n                  isInc\r\n                )\r\n              }\r\n            />\r\n            <BandwidthPlot flowGroup={fg} allocLevels={allocLevels} />\r\n          </div>\r\n        );\r\n      })}\r\n      <div\r\n        style={{\r\n          display: \"grid\",\r\n          gridTemplateRows: \"1fr\",\r\n          gridTemplateColumns: \"1fr 1fr 2fr\",\r\n          columnGap: \"20px\",\r\n          justifyItems: \"start\",\r\n          alignItems: \"center\",\r\n          justifyContent: \"start\",\r\n          fontSize: \"24px\",\r\n        }}\r\n      >\r\n        {flowGroups.length > 1 ? removeFgButton : <div />}\r\n        {flowGroups.length < maxFlowGroups ? addFgButton : <div />}\r\n        <div />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FlowGroupList;\r\n","import React from \"react\";\r\nimport {\r\n  ScatterChart,\r\n  Scatter,\r\n  CartesianGrid,\r\n  XAxis,\r\n  YAxis,\r\n  Tooltip,\r\n  ReferenceLine,\r\n} from \"recharts\";\r\nimport { plotBwCutoff, plotBaseMaxFairShare, fairShareColor } from \"./globals\";\r\nimport {\r\n  bandwidthFunctionDataPoints,\r\n  linkFairShareDataPoints,\r\n  allocatedBandwidthDataPoints,\r\n} from \"./fairShareLogic\";\r\n\r\nconst defaultPlotLinkCap = 40;\r\n\r\n/*\r\nX-axis: link capacity\r\nleft Y-axis: allocated bandwidth\r\nright Y-axis: fair share\r\n*/\r\nfunction LinkAllocationPlot({ flowGroups, allocLevels }) {\r\n  const bwFunctions = flowGroups.map((fg) =>\r\n    bandwidthFunctionDataPoints(fg, allocLevels)\r\n  );\r\n  const fsPts = linkFairShareDataPoints(bwFunctions);\r\n  const plotMaxFs = fsPts.reduce(\r\n    (accum, [cap, fs]) => (fs === Infinity ? accum : Math.max(accum, fs + 1)),\r\n    plotBaseMaxFairShare\r\n  );\r\n  const fairShareData = fsPts.map(([cap, fs], idx) => {\r\n    const prevCap = idx === 0 ? 0 : fsPts[idx - 1][0];\r\n    return fs === Infinity\r\n      ? { fs: plotMaxFs, cap: prevCap }\r\n      : { fs: fs, cap: cap };\r\n  });\r\n  const totalNeededLinkCap = flowGroups.reduce(\r\n    (accum, fg) => accum + fg.estimatedDemand,\r\n    0\r\n  );\r\n  const plotMaxCap = Math.max(totalNeededLinkCap + 5, defaultPlotLinkCap);\r\n  const allocatedBwPts = allocatedBandwidthDataPoints(bwFunctions).map(\r\n    (allocBwPts) => {\r\n      return allocBwPts.map(([availableBw, allocatedBw]) => {\r\n        return availableBw === Infinity\r\n          ? { cap: plotMaxCap, allocBw: allocatedBw }\r\n          : { cap: availableBw, allocBw: allocatedBw };\r\n      });\r\n    }\r\n  );\r\n\r\n  const availableBwTicks = [];\r\n  const availableBwTickStep = 2.5;\r\n  for (let i = 0; i <= plotMaxCap; i += availableBwTickStep) {\r\n    availableBwTicks.push(i);\r\n  }\r\n  const fsTicks = [];\r\n  const fsTickStep = 0.5;\r\n  for (let i = 0; i <= plotMaxFs; i += fsTickStep) {\r\n    fsTicks.push(i);\r\n  }\r\n  const allocatedBwTicks = [];\r\n  const allocatedBwTickStep = 2.5;\r\n  for (let i = 0; i <= plotBwCutoff; i += allocatedBwTickStep) {\r\n    allocatedBwTicks.push(i);\r\n  }\r\n\r\n  return (\r\n    <ScatterChart\r\n      width={644}\r\n      height={390}\r\n      name={`Available vs allocated bandwidth`}\r\n      margin={{ top: 5, right: 5, left: 5, bottom: 5 }}\r\n    >\r\n      <CartesianGrid />\r\n      <XAxis\r\n        type=\"number\"\r\n        dataKey=\"cap\"\r\n        domain={[0, plotMaxCap]}\r\n        label={{ value: \"Link Capacity\", position: \"insideBottom\" }}\r\n        height={40}\r\n        name=\"Link Capacity\"\r\n        ticks={availableBwTicks}\r\n        minTickGap={2}\r\n      />\r\n      <YAxis\r\n        type=\"number\"\r\n        dataKey=\"allocBw\"\r\n        domain={[0, plotMaxFs]}\r\n        name=\"Allocated Bandwidth\"\r\n        label={{\r\n          value: \"Allocated Bandwidth\",\r\n          position: \"insideLeft\",\r\n          style: { textAnchor: \"middle\" },\r\n          angle: -90,\r\n        }}\r\n        width={50}\r\n        ticks={allocatedBwTicks}\r\n        orientation={\"left\"}\r\n        minTickGap={0}\r\n        interval={0}\r\n        yAxisId=\"left\"\r\n      />\r\n      <YAxis\r\n        type=\"number\"\r\n        dataKey=\"fs\"\r\n        domain={[0, plotMaxFs]}\r\n        name=\"Fair Share\"\r\n        label={{\r\n          value: \"Fair Share\",\r\n          position: \"insideRight\",\r\n          style: { textAnchor: \"middle\" },\r\n          angle: -90,\r\n        }}\r\n        width={50}\r\n        ticks={fsTicks}\r\n        orientation={\"right\"}\r\n        minTickGap={0}\r\n        interval={0}\r\n        yAxisId=\"right\"\r\n      />\r\n      <Tooltip />\r\n      {/* <Legend /> */}\r\n      <Scatter\r\n        name=\"Fair Share\"\r\n        data={fairShareData}\r\n        fill={fairShareColor}\r\n        line={{ strokeWidth: 2 }}\r\n        shape=\"cross\"\r\n        yAxisId=\"right\"\r\n      />\r\n      {allocatedBwPts.map((allocBwPoints, idx) => {\r\n        return (\r\n          <Scatter\r\n            key={`ab${idx}`}\r\n            name=\"Allocated Bandwidth\"\r\n            data={allocBwPoints}\r\n            fill={flowGroups[idx].color}\r\n            line={{ strokeWidth: 2.5 }}\r\n            yAxisId=\"left\"\r\n          />\r\n        );\r\n      })}\r\n      {flowGroups.map((fg, idx) => {\r\n        return (\r\n          <ReferenceLine\r\n            key={`ed${idx}`}\r\n            y={fg.estimatedDemand}\r\n            yAxisId=\"left\"\r\n            label={{\r\n              value: \"Est. demand\",\r\n              fill: fg.color,\r\n              position: \"insideBottomLeft\",\r\n            }}\r\n            stroke={fg.color}\r\n            strokeDasharray=\"3 3\"\r\n            strokeWidth={0.8}\r\n            isFront={true}\r\n          />\r\n        );\r\n      })}\r\n      {allocLevels.map((allocLvl, idx) => {\r\n        return (\r\n          <ReferenceLine\r\n            key={`alloc${idx}`}\r\n            y={allocLvl.maxFairShare}\r\n            yAxisId=\"right\"\r\n            stroke={fairShareColor}\r\n            label={{\r\n              value: allocLvl.name + \" alloc.\",\r\n              position: \"insideTopRight\",\r\n              fill: fairShareColor,\r\n            }}\r\n            strokeDasharray=\"3 3\"\r\n            strokeWidth={0.8}\r\n          />\r\n        );\r\n      })}\r\n    </ScatterChart>\r\n  );\r\n}\r\n\r\nexport default LinkAllocationPlot;\r\n","import React from \"react\";\r\n\r\nfunction AllocationLevelTable({ allocLevels }) {\r\n  //init data\r\n  const headers = [\"Allocation Level\", \"Fair Share\"];\r\n  const entries = [];\r\n  for (let i = 0; i < allocLevels.length; i++) {\r\n    entries.push(allocLevels[i].name);\r\n    const prevFs = i === 0 ? 0 : allocLevels[i - 1].maxFairShare;\r\n    const fs = allocLevels[i].maxFairShare;\r\n    entries.push(`${prevFs}-${fs === Infinity ? \"\\u221E\" : fs}`);\r\n  }\r\n\r\n  //formatting\r\n  const borderStyle = \"2px solid black\";\r\n  const tableStyle = {\r\n    borderTop: borderStyle,\r\n    borderLeft: borderStyle,\r\n  };\r\n  const entryStyle = {\r\n    padding: \"0.2em\",\r\n    borderBottom: borderStyle,\r\n    borderRight: borderStyle,\r\n    textAlign: \"center\",\r\n  };\r\n  const headerStyle = { ...entryStyle };\r\n  headerStyle.fontWeight = \"bold\";\r\n\r\n  const divs = [];\r\n  for (let i = 0; i < headers.length; i += 1) {\r\n    divs.push(\r\n      <div key={`h${i}`} style={headerStyle}>\r\n        {headers[i]}\r\n      </div>\r\n    );\r\n  }\r\n  for (let i = 0; i < entries.length; i += 1) {\r\n    divs.push(\r\n      <div key={`e${i}`} style={entryStyle}>\r\n        {entries[i]}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div style={tableStyle}>\r\n      <div\r\n        style={{\r\n          display: \"grid\",\r\n          gridTemplateRows: `repeat(${allocLevels.length + 1}, 1fr)`,\r\n          gridTemplateColumns: \"auto auto\",\r\n        }}\r\n      >\r\n        {divs.map((div) => div)}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default AllocationLevelTable;\r\n","//example used in the paper (Table 1, Figures 3-4)\r\n//we use it as default functions for the app\r\n//as well as in unit tests\r\n\r\n\r\n\r\nimport { makeEmptyFlowGroup } from \"./fairShareLogic\";\r\n\r\n//allocation levels should be sorted from most prioritary to least\r\n//guaranteed has the range of fair share [0, 2], and best effort has the range [2, +inf]\r\nexport const allocationLevelsFromPaper = () => [\r\n  { name: \"Guaranteed\", maxFairShare: 2 },\r\n  { name: \"Best Effort\", maxFairShare: Infinity },\r\n];\r\n\r\n//specific flow groups from the paper\r\n//they can be used as defaults for the app\r\n//Table 1 (a)\r\nexport const flowGroup1FromPaper = () => {\r\n  const fg1 = makeEmptyFlowGroup(\"flowGroup1\", \"#6864b8\", 15, 2);\r\n  fg1.allocLevels[1][0] = [10, 20];\r\n  fg1.allocLevels[1].push([Infinity, 5]);\r\n  return fg1;\r\n};\r\n\r\n//Table 1 (b)\r\nexport const flowGroup2FromPaper = () => {\r\n  const fg2 = makeEmptyFlowGroup(\"flowGroup2\", \"#62aa7d\", 20, 2);\r\n  fg2.allocLevels[0][0] = [10, 10];\r\n  fg2.allocLevels[1][0][1] = 10;\r\n  return fg2;\r\n};\r\n","import { useImmer } from \"use-immer\";\nimport \"./App.css\";\nimport FlowGroupList from \"./FlowGroupList\";\nimport LinkAllocationPlot from \"./LinkAllocationPlot\";\nimport AllocationLevelTable from \"./AllocationLevelTable\";\nimport {\n  allocationLevelsFromPaper,\n  flowGroup1FromPaper,\n  flowGroup2FromPaper,\n} from \"./paperExamples\";\nimport { maxEstDemand, maxFlowGroups } from \"./globals\";\n// eslint-disable-next-line\nimport { allTests } from \"./tests\";\nimport { makeEmptyFlowGroup } from \"./fairShareLogic\";\n\nconst fgColors = [\n  \"#6864b8\",\n  \"#62aa7d\",\n  \"#DEA200\",\n  \"#CC33CC\",\n  \"#0061CD\",\n  \"#BC1E46\",\n];\n\nfunction App() {\n  // allTests();\n\n  /* Currently, the UI does not allow for a way to modify the allocation levels,\n  so they are fixed, but the code is designed to be extendible to an arbitrary number */\n  // eslint-disable-next-line\n  const [allocLevels, updateAllocLevels] = useImmer(\n    allocationLevelsFromPaper()\n  );\n  const [flowGroups, updateFlowGroups] = useImmer([\n    flowGroup1FromPaper(),\n    flowGroup2FromPaper(),\n  ]);\n\n  const handleNumFlowGroups = (isIncrement) => {\n    updateFlowGroups((draftFgs) => {\n      const idx = draftFgs.length;\n      if (isIncrement) {\n        if (idx === maxFlowGroups) return;\n        draftFgs.push(\n          makeEmptyFlowGroup(\n            `flowGroup${idx + 1}`,\n            fgColors[idx],\n            1,\n            allocLevels.length\n          )\n        );\n      } else {\n        if (idx === 1) return;\n        draftFgs.pop();\n      }\n    });\n  };\n\n  const handleEstimatedDemand = (fgIdx, isIncrement) => {\n    updateFlowGroups((draftFgs) => {\n      const fg = draftFgs[fgIdx];\n      if (isIncrement) {\n        if (fg.estimatedDemand < maxEstDemand) fg.estimatedDemand += 1;\n      } else {\n        if (fg.estimatedDemand > 0) fg.estimatedDemand -= 1;\n      }\n    });\n  };\n\n  const handleNumWeightThresholds = (fgIdx, allocLvlIdx, isIncrement) => {\n    updateFlowGroups((draftFgs) => {\n      const fg = draftFgs[fgIdx];\n      const isLastLvl = allocLvlIdx === fg.allocLevels.length - 1;\n      const th = fg.allocLevels[allocLvlIdx]; //thresholds\n      const n = th.length;\n\n      //remove case\n      if (!isIncrement) {\n        if (n < 2) return;\n        th.pop();\n        if (isLastLvl) th[n - 2][0] = Infinity;\n        return;\n      }\n\n      //add case\n      if (n === 0) {\n        th.push([isLastLvl ? Infinity : 0, 0]);\n      } else {\n        const [lastBw, lastW] = th[n - 1];\n        th.push([lastBw, lastW]);\n        if (isLastLvl) {\n          //only the last bw should be infinite\n          th[n - 1][0] = n === 1 ? 0 : th[n - 2][0];\n        }\n      }\n    });\n  };\n\n  const handleWeightThreshold = (\n    fgIdx,\n    allocLvlIdx,\n    weightThresholdIdx,\n    isWeight,\n    isIncrement\n  ) => {\n    updateFlowGroups((draftFgs) => {\n      const fg = draftFgs[fgIdx];\n      const th = fg.allocLevels[allocLvlIdx][weightThresholdIdx];\n      if (isIncrement) {\n        if (isWeight) th[1] += 1;\n        else th[0] += 1;\n      } else {\n        if (isWeight) th[1] -= 1;\n        else th[0] -= 1;\n      }\n    });\n  };\n\n  /* flow group configuration tables and bandwidth functions to the left,\n  bandwidth function aggregation to the right */\n  const mainDivStyle = {\n    display: \"grid\",\n    gridTemplateRows: \"1fr\",\n    gridTemplateColumns: \"auto auto\",\n    columnGap: \"20px\",\n    justifyItems: \"start\",\n    alignItems: \"center\",\n    justifyContent: \"start\",\n    marginLeft: \"15px\",\n    marginTop: \"15px\",\n  };\n\n  //allocation level table on top, list of flow group tables/bandwidth functions below\n  const flowGroupDivStyle = {\n    display: \"grid\",\n    gridTemplateRows: \"auto auto\",\n    gridTemplateColumns: \"auto\",\n    rowGap: \"20px\",\n    justifyItems: \"center\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  };\n\n  //header on top, main plot below\n  const bandwidthAggregationDivStyle = flowGroupDivStyle;\n\n  return (\n    <div style={mainDivStyle}>\n      <div style={flowGroupDivStyle}>\n        <AllocationLevelTable allocLevels={allocLevels} />\n        <FlowGroupList\n          flowGroups={flowGroups}\n          allocLevels={allocLevels}\n          handleEstDemand={handleEstimatedDemand}\n          handleNumWeightThresholds={handleNumWeightThresholds}\n          handleWeightThreshold={handleWeightThreshold}\n          handleNumFlowGroups={handleNumFlowGroups}\n        />\n      </div>\n      <div style={bandwidthAggregationDivStyle}>\n        <div style={{ fontSize: \"24px\" }}>Bandwidth function aggregation</div>\n        <LinkAllocationPlot flowGroups={flowGroups} allocLevels={allocLevels} />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}